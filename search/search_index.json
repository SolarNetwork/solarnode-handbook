{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SolarNode Handbook","text":"<p>This handbook provides guides and reference documentation about SolarNode, the distributed computing part of SolarNetwork.</p> <p> SolarNode is the swiss army knife for IoT monitoring and control. It is deployed on inexpensive computers in homes, buildings, vehicles, and even EV chargers, connected to any number of sensors, meters, building automation systems, and more. There are several SolarNode icons in the image below. Can you spot them all?</p> <p></p>"},{"location":"#user-guide","title":"User Guide","text":"<p>For information on getting and using SolarNode, see the User Guide.</p>"},{"location":"#developer-guide","title":"Developer Guide","text":"<p>For information on working on the SolarNode codebase, such as writing a plugin, see the Developer Guide.</p>"},{"location":"developers/","title":"Developer Guide","text":"<p>This section of the handbook is geared towards developers working with the SolarNode codebase to develop a plugin.</p>"},{"location":"developers/#solarnode-source","title":"SolarNode source","text":"<p>The core SolarNode platform code is available on GitHub.</p>"},{"location":"developers/#getting-started","title":"Getting started","text":"<p>See the SolarNode Development Guide to set up your own development environment for writing SolarNode plugins.</p>"},{"location":"developers/#solarnode-debugging","title":"SolarNode debugging","text":"<p>You can enable Java remote debugging for SolarNode on a node device for SolarNode plugin development or troubleshooting by modifying the SolarNode service environment. Once enabled, you can use SSH port forwarding to enable Java remote debugging in your Java IDE of choice.</p> <p>To enable Java remote debugging, copy the <code>/etc/solarnode/env.conf.example</code> file to <code>/etc/solarnode/env.conf</code>. The example already includes this support, using port <code>9142</code> for the debugging port. Then restart the <code>solarnode</code> service:</p> Creating a custom SolarNode environment with debugging support<pre><code>$ cp /etc/solarnode/env.conf.example /etc/solarnode/env.conf\n$ sn-restart\n</code></pre> <p>Then you can use <code>ssh</code> from your development machine to forward a local port to the node's <code>9142</code> port, and then have your favorite IDE establish a remote debugging connection on your local port.</p> <p>For example, on a Linux or macOS machine you could forward port <code>8000</code> to a node's port <code>9142</code> like this:</p> Creating a port-forwarding SSH connection from a development machine to SolarNode<pre><code>$ ssh -L8000:localhost:9142 solar@solarnode\n</code></pre> <p>Once that <code>ssh</code> connection is established, your IDE can be used to connect to <code>localhost:8000</code> for a remote Java debugging session.</p>"},{"location":"developers/osgi/","title":"Plugins","text":"<p>The SolarNode platform has been designed to be highly modular and dynamic, by using a plugin-based architecture. The plugin system SolarNode uses is based on the OSGi specification, where plugins are implemented as OSGi bundles. SolarNode can be thought of as a collection of OSGi bundles that, when combined and deployed together in an OSGi framework like Eclipse Equinox, form the complete SolarNode platform.</p> <p>To summarize: everything in SolarNode is a plugin!</p> <p>OSGi bundles and Eclipse plug-ins</p> <p>Each OSGi bundle in SolarNode comes configured as an Eclipse IDE (or simply Eclipse) plug-in project. Eclipse refers to OSGi bundles as \"plug-ins\" and its OSGi development tools are collectively known as the Plug-in Development Environment, or PDE for short. We use the terms bundle and plug-in and plugin somewhat interchangably in the SolarNode project. Although Eclipse is not actually required for SolarNode development, it is very convenient.</p> <p>Practically speaking a plugin, which is an OSGi bundle, is simply a Java JAR file that includes the Java code implementing your plugin and some OSGi metadata in its Manifest. For example, here is the contents of the <code>net.solarnetwork.common.jdt</code> plugin JAR:</p> <pre><code>META-INF/MANIFEST.MF\nnet/solarnetwork/common/jdt/Activator.class\nnet/solarnetwork/common/jdt/ClassLoaderNameEnvironment.class\nnet/solarnetwork/common/jdt/CollectingCompilerRequestor.class\nnet/solarnetwork/common/jdt/CompilerUtils.class\nnet/solarnetwork/common/jdt/JdtJavaCompiler.class\nnet/solarnetwork/common/jdt/MapClassLoader.class\nnet/solarnetwork/common/jdt/ResourceCompilationUnit.class\n</code></pre>"},{"location":"developers/osgi/#services","title":"Services","text":"<p>Central to the plugin architecture SolarNode uses is the concept of a service. In SolarNode a service is defined by a Java interface. A plugin can advertise a service to the SolarNode runtime. Plugins can lookup a service in the SolarNode runtime and then invoke the methods defined on it.</p> <p>The advertising/lookup framework SolarNode uses is provided by OSGi. OSGi provides several ways to manage services. In SolarNode the most common is to use Blueprint XML documents to both publish services (advertise) and acquire references to services (lookup).</p>"},{"location":"developers/osgi/blueprint-compendium/","title":"Gemini Blueprint Compendium","text":"<p>The Gemini Blueprint implementation provides some useful extensions that SolarNode makes frequent use of.  To use the extensions you need to declare the Gemini Blueprint Compendium namespace in your Blueprint  XML file, like this:</p> Gemini Blueprint Compendium XML declaration<pre><code>&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:osgix=\"http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\"\nxmlns:beans=\"http://www.springframework.org/schema/beans\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium/gemini-blueprint-compendium.xsd\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n</code></pre> <p>This example declares the Gemini Blueprint Compendium XML namespace prefix <code>osgix</code> and a related Spring Beans namespace prefix <code>beans</code>. You will see those used throughout SolarNode.</p>"},{"location":"developers/osgi/blueprint-compendium/#managed-properties","title":"Managed Properties","text":"<p>Managed Properties provide a way to use the Configuration Admin service to manage user-configurable service properties. Conceptually it is like linking a class to a set of dynamic runtime Settings: Configuration Admin provides change event and persistence APIs for the settings, and the Managed Properties applies those settings to the linked service.</p> <p>Imagine you have a service class <code>MyService</code> with a configurable property <code>level</code>. We can make that property a managed, persistable setting by adding a <code>&lt;osgix:managed-properties&gt;</code> element to our Blueprint XML, like this:</p> MyService classMyService localizationBlueprint XML <pre><code>package com.example;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport net.solarnetwork.node.service.support.BaseIdentifiable;\nimport net.solarnetwork.settings.SettingSpecifier;\nimport net.solarnetwork.settings.SettingSpecifierProvider;\nimport net.solarnetwork.settings.SettingsChangeObserver;\nimport net.solarnetwork.settings.support.BasicTextFieldSettingSpecifier;\n\n/**\n * My super-duper service.\n *\n * @author matt\n * @version 1.0\n */\npublic class MyService extends BaseIdentifiable\nimplements SettingsChangeObserver, SettingSpecifierProvider {\n\nprivate int level;\n\n@Override\npublic String getSettingUid() {\nreturn \"com.example.MyService\"; // (1)!\n}\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nreturn Collections.singletonList(\nnew BasicTextFieldSettingSpecifier(\"level\", String.valueOf(0)));\n}\n\n@Override\npublic void configurationChanged(Map&lt;String, Object&gt; properties) {\n// the settings have changed; do something\n}\n\npublic int getLevel() {\nreturn level;\n}\n\npublic void setLevel(int level) {\nthis.level = level;\n}\n\n}\n</code></pre> <ol> <li>The setting UID will be the Configuration Admin PID</li> </ol> <pre><code>title = Super-duper Service\ndesc = This service does it all.\n\nlevel.key = Level\nlevel.desc = This one goes to 11.\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:osgix=\"http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\"\nxmlns:beans=\"http://www.springframework.org/schema/beans\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium/gemini-blueprint-compendium.xsd\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n&lt;service&gt;\n&lt;interfaces&gt;\n&lt;value&gt;net.solarnetwork.settings.SettingSpecifierProvider&lt;/value&gt;\n&lt;/interfaces&gt;\n&lt;bean class=\"com.example.MyService\"&gt;&lt;!-- (1)! --&gt;\n&lt;osgix:managed-properties\npersistent-id=\"com.example.MyService\"\nautowire-on-update=\"true\"\nupdate-method=\"configurationChanged\"/&gt;\n&lt;property name=\"messageSource\"&gt;\n&lt;bean class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt;\n&lt;property name=\"basenames\" value=\"com.example.MyService\"/&gt;\n&lt;/bean&gt;\n&lt;/property&gt;\n&lt;/bean&gt;\n&lt;/service&gt;\n\n&lt;/blueprint&gt;\n</code></pre> <ol> <li>You nest the <code>&lt;osgi:managed-properties&gt;</code> element within the actual service <code>&lt;bean&gt;</code> element    you want to apply the managed settings on.<ul> <li>note how the <code>persistent-id</code> attribute value matches the <code>getSettingsUid()</code> value in   <code>MyService.java</code></li> <li>the <code>autowire-on-update</code> method toggles having the Managed Properties automatically applied by   Gemini Blueprint; you can set to <code>false</code> and provide an <code>update-method</code> if you want to handle   changes yourself</li> <li>the <code>update-method</code> attribute is optional; it provides a way for the service to be notified   after the Configuration Admin settings have been applied.</li> </ul> </li> </ol> <p>When this plugin is deployed in SolarNode, the component will appear on the main Settings page and offer a configurable Level setting, like this:</p> <p></p>"},{"location":"developers/osgi/blueprint-compendium/#managed-service-factory","title":"Managed Service Factory","text":"<p>The Managed Service Factory service provide a way to use the Configuration Admin service to manage multiple copies of a user-configurable service's properties. Conceptually it is like linking a class to a set of dynamic runtime Settings, but you can create as many independent copies as you like. Configuration Admin provides change event and persistence APIs for the settings, and the Managed Service Factory applies those settings to each linked service instance.</p> <p>Imagine you have a service class <code>ManagedService</code> with a configurable property <code>level</code>. We can make that property a factory of managed, persistable settings by adding a <code>&lt;osgix:managed-service-factory&gt;</code> element to our Blueprint XML, like this:</p> MyService classMyService localizationBlueprint XML <pre><code>package com.example;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport net.solarnetwork.node.service.support.BaseIdentifiable;\nimport net.solarnetwork.settings.SettingSpecifier;\nimport net.solarnetwork.settings.SettingSpecifierProvider;\nimport net.solarnetwork.settings.SettingsChangeObserver;\nimport net.solarnetwork.settings.support.BasicTextFieldSettingSpecifier;\n\n/**\n * My super-duper managed service.\n *\n * @author matt\n * @version 1.0\n */\npublic class ManagedService extends BaseIdentifiable\nimplements SettingsChangeObserver, SettingSpecifierProvider {\n\nprivate int level;\n\n@Override\npublic String getSettingUid() {\nreturn \"com.example.ManagedService\"; // (1)!\n}\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nreturn Collections.singletonList(\nnew BasicTextFieldSettingSpecifier(\"level\", String.valueOf(0)));\n}\n\n@Override\npublic void configurationChanged(Map&lt;String, Object&gt; properties) {\n// the settings have changed; do something\n}\n\npublic int getLevel() {\nreturn level;\n}\n\npublic void setLevel(int level) {\nthis.level = level;\n}\n\n}\n</code></pre> <ol> <li>The setting UID will be the Configuration Admin factory PID</li> </ol> <pre><code>title = Super-duper Managed Service\ndesc = This managed service does it all.\n\nlevel.key = Level\nlevel.desc = This one goes to 11.\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:osgix=\"http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\"\nxmlns:beans=\"http://www.springframework.org/schema/beans\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium/gemini-blueprint-compendium.xsd\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt;\n&lt;property name=\"basenames\" value=\"com.example.ManagedService\"/&gt;\n&lt;/bean&gt;\n\n&lt;service interface=\"net.solarnetwork.settings.SettingSpecifierProviderFactory\"&gt;&lt;!-- (1)! --&gt;\n&lt;bean class=\"net.solarnetwork.settings.support.BasicSettingSpecifierProviderFactory\"&gt;\n&lt;property name=\"displayName\" value=\"Super-duper Managed Service\"/&gt;\n&lt;property name=\"factoryUid\" value=\"com.example.ManagedService\"/&gt;&lt;!-- (2)! --&gt;\n&lt;property name=\"messageSource\" ref=\"messageSource\"/&gt;\n&lt;/bean&gt;\n&lt;/service&gt;\n\n&lt;osgix:managed-service-factory\nfactory-pid=\"com.example.ManagedService\"\nautowire-on-update=\"true\"\nupdate-method=\"configurationChanged\"&gt;&lt;!-- (3)! --&gt;\n&lt;osgix:interfaces&gt;\n&lt;beans:value&gt;net.solarnetwork.settings.SettingSpecifierProvider&lt;/beans:value&gt;\n&lt;/osgix:interfaces&gt;\n&lt;osgix:service-properties&gt;\n&lt;beans:entry key=\"settingPid\" value=\"com.example.ManagedService\"/&gt;\n&lt;/osgix:service-properties&gt;\n&lt;bean class=\"com.example.ManagedService\"&gt;\n&lt;property name=\"messageSource\" ref=\"messageSource\"/&gt;\n&lt;/bean&gt;\n&lt;/osgix:managed-service-factory&gt;\n\n&lt;/blueprint&gt;\n</code></pre> <ol> <li>The <code>SettingSpecifierProviderFactory</code> service is what makes the managed service factory    appear as a component in the SolarNode Settings UI.</li> <li>The <code>factoryUid</code> defines the Configuration Admin factory PID and the Settings UID.</li> <li>You add a <code>&lt;osgix:managed-service-factory&gt;</code> element in your Blueprint XML, with a nested    <code>&lt;bean&gt;</code> \"template\" within it. The template bean will be instantiated for each service    instance instantiated by the Managed Service Factory.<ul> <li>note how the <code>factory-pid</code> attribute value matches the <code>getSettingsUid()</code> value in   <code>ManagedService.java</code> and the <code>factoryUid</code> declared in #2.</li> <li>the <code>autowire-on-update</code> method toggles having the Managed Properties automatically applied by   Gemini Blueprint; you can set to <code>false</code> and provide an <code>update-method</code> if you want to handle   changes yourself</li> <li>the <code>update-method</code> attribute is optional; it provides a way for the service to be notified   after the Configuration Admin settings have been applied.</li> </ul> </li> </ol> <p>When this plugin is deployed in SolarNode, the managed component will appear on the main Settings page like this:</p> <p></p> <p>After clicking on the Manage button next to this component, the Settings UI allows you to create any number of instances of the component, each with their own setting values. Here is a screen shot showing two instances having been created:</p> <p></p>"},{"location":"developers/osgi/blueprint/","title":"Blueprint","text":"<p>SolarNode supports the OSGi Blueprint Container Specification so plugins can declare their service dependencies and register their services by way of an XML file deployed with the plugin. If you are familiar with the Spring Framework's XML configuration, you will find Blueprint very similar. SolarNode uses the Eclipse Gemini implementation of the Blueprint specification, which is directly derived from Spring Framework.</p> <p>Note</p> <p>This guide will not document the full Blueprint XML syntax. Rather, it will attempt to showcase the most common parts used in SolarNode. Refer to the Blueprint Container Specification for full details of the specification.</p>"},{"location":"developers/osgi/blueprint/#example","title":"Example","text":"<p>Imagine you are working on a plugin and have a <code>com.example.Greeter</code> interface you would like to register as a service for other plugins to use, and an implementation of that service in  <code>com.example.HelloGreeter</code> that relies on the Placeholder  Service provided by SolarNode:</p> Greeter serviceHelloGreeter implementation <pre><code>package com.example;\npublic interface Greeter {\n\n/**\n     * Greet something with a given name.\n     * @param name the name to greet\n     * @return the greeting\n     */\nString greet(String name);\n\n}\n</code></pre> <pre><code>package com.example;\nimport net.solarnetwork.node.service.PlaceholderService;\npublic class HelloGreeter implements Greeter {\n\nprivate final PlaceholderService placeholderService;\n\npublic HelloGreeter(PlaceholderService placeholderService) {\nsuper();\nthis.placeholderService = placeholderService;\n}\n\n@Override\npublic String greet(String name) {\nreturn placeholderService.resolvePlaceholders(\nString.format(\"Hello %s, from {myName}.\", name),\nnull);\n}\n}\n</code></pre> <p>Assuming the <code>PlaceholderService</code> will resolve <code>{name}</code> to <code>Office Node</code>, we would expect the <code>greet()</code> method to run like this:</p> <pre><code>Greeter greeter = resolveGreeterService();\nString result = greeter.greet(\"Joe\");\n// result is \"Hello Joe, from Office Node.\"\n</code></pre> <p>In the plugin we then need to:</p> <ol> <li>Obtain a <code>net.solarnetwork.node.service.PlaceholderService</code> to pass to the     <code>HelloGreeter(PlaceholderService)</code> constructor</li> <li>Register  the <code>HelloGreeter</code> comopnent as a <code>com.example.Greeter</code> service in the SolarNode     platform</li> </ol> <p>Here is an example Blueprint XML document that does both:</p> Blueprint XML example<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\"&gt;\n\n&lt;!-- Declare a reference (lookup) to the PlaceholderService --&gt;\n&lt;reference id=\"placeholderService\"\ninterface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n\n&lt;service interface=\"com.example.Greeter\"&gt;\n&lt;bean class=\"com.example.HelloGreeter\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;/bean&gt;\n&lt;/service&gt;\n\n&lt;/blueprint&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#blueprint-xml-resources","title":"Blueprint XML Resources","text":"<p>Blueprint XML documents are added to a plugin's <code>OSGI-INF/blueprint</code> classpath location. A plugin can provide any number of Blueprint XML documents there, but often a single file is sufficient and a common convention in SolarNode is to name it <code>module.xml</code>.</p>"},{"location":"developers/osgi/blueprint/#xml-syntax","title":"XML Syntax","text":"<p>A minimal Blueprint XML file is structured like this:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\"&gt;\n\n&lt;!-- Plugin components configured here --&gt;\n\n&lt;/blueprint&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#service-references","title":"Service References","text":"<p>To make use of services registered by SolarNode plugins, you declare a reference to that service so you may refer to it elsewhere within the Blueprint XML. For example, imagine you wanted to use the Placeholder Service in your component. You would obtain a reference to that like this:</p> <pre><code>&lt;reference id=\"placeholderService\"\ninterface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n</code></pre> <p>The <code>id</code> attribute allows you to refer to this service elsewhere in your Blueprint XML, while <code>interface</code> declares the fully-qualified Java interface of the service you want to use.</p>"},{"location":"developers/osgi/blueprint/#components","title":"Components","text":"<p>Components in Blueprint are Java classes you would like instantiated when your plugin starts. They are declared using a <code>&lt;bean&gt;</code> element in Blueprint XML. You can assign each component a unique identifier using an <code>id</code> attribute, and then you can refer to that component in other components.</p> <p>Imagine an example component class <code>com.example.MyComponent</code>:</p> <pre><code>package com.example;\n\nimport net.solarnetwork.node.service.PlaceholderService;\n\npublic class MyComponent {\n\nprivate final PlaceholderService placeholderService;\nprivate int minimum;\n\npublic MyComponent(PlaceholderService placeholderService) {\nsuper();\nthis.placeholderService = placeholderService;\n}\n\npublic String go() {\nreturn PlaceholderService.resolvePlaceholders(placeholderService,\n\"{building}/temp\", null);\n}\n\npublic int getMinimum() {\nreturn minimum;\n}\n\npublic void setMinimum(int minimum) {\nthis.minimum = minimum;\n}\n}\n</code></pre> <p>Here is how that component could be declared in Blueprint:</p> <pre><code>&lt;reference id=\"placeholderService\"\ninterface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n\n&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;property name=\"minimum\" value=\"10\"/&gt;\n&lt;/bean&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#constructor-arguments","title":"Constructor Arguments","text":"<p>If your component requires any constructor arguments, they can be specified with nested <code>&lt;argument&gt;</code> elements in Blueprint. The <code>&lt;argument&gt;</code> value can be specified as a reference to another component using a <code>ref</code> attribute whose value is the <code>id</code> of that component, or as a literal value using a <code>value</code> attribute.</p> <p>For example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;argument value=\"10\"&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#property-accessors","title":"Property Accessors","text":"<p>You can configure mutable class properties on a component with nested <code>&lt;property name=\"\"&gt;</code> elements in Blueprint. A mutable property is a Java setter method. For example an <code>int</code> property <code>minimum</code> would be associated with a Java setter method <code>public void setMinimum(int value)</code>.</p> <p>The <code>&lt;property&gt;</code> value can be specified as a reference to another component using a <code>ref</code> attribute whose value is the <code>id</code> of that component, or as a literal value using a <code>value</code> attribute.</p> <p>For example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;property name=\"placeholderService\" ref=\"placeholderService\"&gt;\n&lt;argument name=\"minimum\" value=\"10\"&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#startstop-hooks","title":"Start/Stop Hooks","text":"<p>Blueprint can invoke a method on your component when it has finished instantiating and configuring the object (when the plugin starts), and another when it destroys the instance (when the plugin is stopped). You simply provide the name of the method you would like Blueprint to call in the <code>init-method</code> and <code>destroy-method</code> attributes of the <code>&lt;bean&gt;</code> element. For example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"\ninit-method=\"startup\"\ndestroy-method=\"shutdown\"&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#service-registration","title":"Service Registration","text":"<p>You can make any component available to other plugins by registering the component with a <code>&lt;service&gt;</code> element that declares what interface(s) your component provides. Once registered, other plugins can make use of your component, for example by declaring a <code>&lt;referenece&gt;</code> to your component class in their Blueprint XML.</p> <p>Note</p> <p>You can only register Java interfaces as services, not classes.</p> <p>For example, imagine a <code>com.example.Startable</code> interface like this:</p> <pre><code>package com.example;\npublic interface Startable {\n/**\n     * Start!\n     * @return the result\n     */\nString go();\n}\n</code></pre> <p>We could implement that interface in the <code>MyComponent</code> class, like this:</p> <pre><code>package com.example;\n\npublic class MyComponent implements Startable {\n\n@Override\npublic String go() {\nreturn \"Gone!\";\n}\n}\n</code></pre> <p>We can register <code>MyComponent</code> as a <code>Startable</code> service using a <code>&lt;service&gt;</code> element like this in Blueprint:</p> Direct service componentIndirect service component <pre><code>&lt;service interface=\"com.example.Startable\"&gt;\n&lt;!-- The service implementation is nested directly within --&gt;\n&lt;bean class=\"com.example.MyComponent\"/&gt;\n&lt;/service&gt;\n</code></pre> <pre><code>&lt;!-- The service implementation is referenced indirectly... --&gt;\n&lt;service ref=\"myComponent\" interface=\"com.example.Startable\"/&gt;\n\n&lt;!-- ... to a bean with a matching id attribute --&gt;\n&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"/&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#multiple-service-interfaces","title":"Multiple Service Interfaces","text":"<p>You can advertise any number of service interfaces that your component supports, by nesting an <code>&lt;interfaces&gt;</code> element within the <code>&lt;service&gt;</code> element, in place of the <code>interface</code> attribute. For example:</p> <pre><code>&lt;service ref=\"myComponent\"&gt;\n&lt;interfaces&gt;\n&lt;value&gt;com.example.Startable&lt;/value&gt;\n&lt;value&gt;com.example.Stopable&lt;/value&gt;\n&lt;/interfaces&gt;\n&lt;/service&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#export-service-packages","title":"Export service packages","text":"<p>For a registered service to be of any use to another plugin, the package the service is defined in must be exported by the plugin hosting that package. That is because the plugin wishing to add a reference to the service will need to import the package in order to use it.</p> <p>For example, the plugin that hosts the <code>com.example.service.MyService</code> service would need a manifest file that includes an <code>Export-Package</code> attribute similar to:</p> <pre><code>Export-Package: com.example.service;version=\"1.0.0\"\n</code></pre>"},{"location":"developers/osgi/configuration-admin/","title":"Configuration Admin","text":"<p>TODO</p>"},{"location":"developers/osgi/life-cycle/","title":"Life cycle","text":"<p>Plugins in SolarNode can be added to and removed from the platform at any time without restarting the SolarNode process, because of the Life Cycle process OSGi manages. The life cycle of a plugin consists of a set of states and OSGi will transition a plugin's state over the course of the plugin's life.</p> <p>The available plugin states are:</p> State Description <code>INSTALLED</code> The plugin has been successfully added to the OSGi framework. <code>RESOLVED</code> All package dependencies that the bundle needs are available. This state indicates that the plugin is either ready to be started or has stopped. <code>STARTING</code> The plugin is being started by the OSGi framework, but it has not finished starting yet. <code>ACTIVE</code> The plugin has been successfully started and is running. <code>STOPPING</code> The plugin is being stopped by the OSGi framework, but it has not finished stopping yet. <code>UNINSTALLED</code> The plugin has been removed by the OSGi framework. It cannot change to another state. <p>The possible changes in state can be visualized in the following state-change diagram:</p> <p> </p> <p>Faisal.akeel, Public domain, via Wikimedia Common</p>"},{"location":"developers/osgi/life-cycle/#activator","title":"Activator","text":"<p>A plugin can opt in to receiving callbacks for the start/stop state transitions by providing an <code>org.osgi.framework.BundleActivator</code> implementation and declaring that class in the <code>Bundle-Activator</code> manifest attribute. This can be useful when a plugin needs to initialize some resources when the plugin is started, and then release those resources when the plugin is stopped.</p> BundleActivator APIBundleActivator implementation exampleManifest declaration example <pre><code>public interface BundleActivator {\n/**\n     * Called when this bundle is started so the Framework can perform the\n     * bundle-specific activities necessary to start this bundle.\n     *\n     * @param context The execution context of the bundle being started.\n     */\npublic void start(BundleContext context) throws Exception;\n\n/**\n     * Called when this bundle is stopped so the Framework can perform the\n     * bundle-specific activities necessary to stop the bundle.\n     *\n     * @param context The execution context of the bundle being stopped.\n     */\npublic void stop(BundleContext context) throws Exception;\n}\n</code></pre> <pre><code>package com.example.activator;\nimport org.osgi.framework.BundleActivator;\nimport org.osgi.framework.BundleContext;\npublic class Activator implements BundleActivator {\n\n@Override\npublic void start(BundleContext bundleContext) throws Exception {\n// initialize resources here\n}\n\n@Override\npublic void stop(BundleContext bundleContext) throws Exception {\n// clean up resources here\n}\n}\n</code></pre> <pre><code>Manifest-Version: 1.0\nBundle-ManifestVersion: 2\nBundle-Name: Example Activator\nBundle-SymbolicName: com.example.activator\nBundle-Version: 1.0.0\nBundle-Activator: com.example.activator.Activator\nImport-Package: org.osgi.framework;version=\"[1.3,2.0)\"\n</code></pre> <p>Tip</p> <p>Often making use of the component life cycle hooks available in Blueprint are sufficient and no <code>BundleActivator</code> is necessary.</p>"},{"location":"developers/osgi/manifest/","title":"Manifest","text":"<p>As SolarNode plugins are OSGi bundles, which are Java JAR files, every plugin automatically includes a <code>META-INF/MANIFEST.MF</code> file as defined in the Java JAR File Specification. The <code>MANIFEST.MF</code> file is where OSGi metadata is included, turning the JAR into an OSGi bundle (plugin).</p>"},{"location":"developers/osgi/manifest/#example","title":"Example","text":"<p>Here is an example snippet from the SolarNode net.solarnetwork.common.jdt plugin:</p> Example plugin MANIFEST.MF<pre><code>Manifest-Version: 1.0\nBundle-ManifestVersion: 2\nBundle-Name: Java Compiler Service (JDT)\nBundle-SymbolicName: net.solarnetwork.common.jdt\nBundle-Description: Java complier using Eclipse JDT.\nBundle-Version: 3.0.0\nBundle-Vendor: SolarNetwork\nBundle-RequiredExecutionEnvironment: JavaSE-1.8\nBundle-Activator: net.solarnetwork.common.jdt.Activator\nExport-Package:\nnet.solarnetwork.common.jdt;version=\"2.0.0\"\nImport-Package:\nnet.solarnetwork.service;version=\"[1.0,2.0)\",\norg.eclipse.jdt.core.compiler,\norg.eclipse.jdt.internal.compiler,\norg.osgi.framework;version=\"[1.5,2.0)\",\norg.slf4j;version=\"[1.7,2.0)\",\norg.springframework.context;version=\"[5.3,6.0)\",\norg.springframework.core.io;version=\"[5.3,6.0)\",\norg.springframework.util;version=\"[5.3,6.0)\"\n</code></pre> <p>The rest of this document will describe this structure in more detail.</p>"},{"location":"developers/osgi/manifest/#versioning","title":"Versioning","text":"<p>In OSGi plugins are always versioned and and Java packages may be versioned. Versions follow Semantic Versioning rules, generally using this syntax:</p> <pre><code>major.minor.patch\n</code></pre> <p>In the manifest example you can see the plugin version <code>3.0.0</code> declared in the <code>Bundle-Version</code> attribute:</p> <pre><code>Bundle-Version: 3.0.0\n</code></pre> <p>The example also declares (exports) a <code>net.solarnetwork.common.jdt</code> package for other plugins to import (use) as version <code>2.0.0</code>, in the <code>Export-Package</code> attribute:</p> <pre><code>Export-Package:\nnet.solarnetwork.common.jdt;version=\"2.0.0\"\n</code></pre> <p>The example also uses (imports) a versioned package <code>net.solarnetwork.service</code> using a version range greater than or equal to <code>1.0</code> and less than <code>2.0</code> and an unversioned package <code>org.eclipse.jdt.core.compiler</code>, in the <code>Import-Package</code> attribute:</p> <pre><code>Import-Package:\nnet.solarnetwork.service;version=\"[1.0,2.0)\",\norg.eclipse.jdt.core.compiler,\n</code></pre> <p>Tip</p> <p>Some plugins, and core Java system packages, do not declare package versions. You should declare package versions in your own plugins.</p>"},{"location":"developers/osgi/manifest/#version-ranges","title":"Version ranges","text":"<p>Some OSGi version attributes allow version ranges to be declared, such as the <code>Import-Package</code> attribute. A version range is a comma-delimited <code>lower,upper</code> specifier. Square brackets are used to represent inclusive  values and round brackets represent exclusive values. A value can be omitted to reprsent an unbounded value. Here are some examples:</p> Range Logic Description <code>[1.0,2.0)</code> 1.0.0 \u2264 x &lt; 2.0.0 Greater than or equal to <code>1.0.0</code> and less than <code>2.0.0</code> <code>(1,3)</code> 1.0.0 &lt; x &lt; 3.0.0 Greater than <code>1.0.0</code> and less than <code>3.0.0</code> <code>[1.3.2,)</code> 1.3.2 \u2264 x Greater than or eequal to <code>1.3.2</code> <code>1.3.2</code> 1.3.2 \u2264 x Greater than or eequal to <code>1.3.2</code> (shorthand notation) <p>Implied unbounded range</p> <p>An inclusive lower, unbounded upper range can be specifeid using a shorthand notation of just the lower bound, like <code>1.3.2</code>.</p>"},{"location":"developers/osgi/manifest/#required-attributes","title":"Required attributes","text":"<p>Each plugin must provide the following attributes:</p> Attribute Example Description <code>Bundle-ManifestVersion</code> 2 declares the OSGi bundle manifest version; always <code>2</code> <code>Bundle-Name</code> Awesome Data Source a concise human-readable name for the plugin <code>Bundle-SymbolicName</code> com.example.awesome a machine-readable, universally unique identifier for the plugin <code>Bundle-Version</code> 1.0.0 the plugin version <code>Bundle-RequiredExecutionEnvironment</code> JavaSE-1.8 a required OSGi execution environment"},{"location":"developers/osgi/manifest/#recommended-attributes","title":"Recommended attributes","text":"<p>Each plugin is recommended to provide the following attributes:</p> Attribute Example Description <code>Bundle-Description</code> An awesome data source that collects awesome data. a longer human-readable description of the plugin <code>Bundle-Vendor</code> ACME Corp the name of the entity or organisation that authored the plugin"},{"location":"developers/osgi/manifest/#common-attributes","title":"Common attributes","text":"<p>Other common manifest attributes are:</p> Attribute Example Description <code>Bundle-Activator</code> com.example.awesome.Activator a fully-qualified Java class name that implements the <code>org.osgi.framework.BundleActivator</code> interface, to handle plugin lifecycle events; see Activator for more information <code>Export-Package</code> net.solarnetwork.common.jdt;version=\"2.0.0\" a package export list <code>Import-Package</code> net.solarnetwork.service;version=\"[1.0,2.0)\" a package dependency list"},{"location":"developers/osgi/manifest/#package-dependencies","title":"Package dependencies","text":"<p>A plugin must declare the Java packages it directly uses in a <code>Import-Package</code> attribute. This attribute accpets a comma-delimited list of package specifications that take the basic form of:</p> <pre><code>PACKAGE;version=\"VERSION\"\n</code></pre> <p>For example here is how the <code>net.solarnetwork.service</code> package, versioned between <code>1.0</code> and <code>2.0</code>, would be declared:</p> <pre><code>Import-Package: net.solarnetwork.service;version=\"[1.0,2.0)\"\n</code></pre> <p>Direct package use means your plugin has code that imports a class from a given package. Classes in an imported package may import other packages indirectly; you do not need to import those packages as well.  For example if you have code like this:</p> <pre><code>import net.solarnetwork.service.OptionalService;\n</code></pre> <p>Then you will need to import the <code>net.solarnetwork.service</code> package.</p> <p>Note</p> <p>The SolarNode platform automatically imports core Java packages like <code>java.*</code> so you do not need to declare those.</p> <p>Also note that in some scenarios a package used by a class in an imported package becomes a direct dependency. For example when you extend a class from an imported package and that class imports other packages. Those other packages may become direct dependencies that you also need to import.</p>"},{"location":"developers/osgi/manifest/#child-package-dependencies","title":"Child package dependencies","text":"<p>If you import a package in your plugin, any child packages that may exist are not imported as well. You must import every individual package you need to use in your plugin.</p> <p>For example to use both <code>net.solarnetwork.service</code> and <code>net.solarnetwork.service.support</code> you would have an <code>Import-Package</code> attribute like this:</p> <pre><code>Import-Package:\nnet.solarnetwork.service;version=\"[1.0,2.0)\",\nnet.solarnetwork.service.support;version=\"[1.1,2.0)\"\n</code></pre>"},{"location":"developers/osgi/manifest/#package-exports","title":"Package exports","text":"<p>A plugin can export any package it provides, making the resources within that package available to other plugins to import and use. Declare exoprted packages with a <code>Export-Package</code> attribute. This attribute takes a comma-delimited list of versioned package specifications. Note that version ranges are not supported: you must declare the exact version of the package you are exporting. For example:</p> <pre><code>Export-Package: com.example.service;version=\"1.0.0\"\n</code></pre> <p>Note</p> <p>Exported packages should not be confused with services. Exported packages give other plugins access to the classes and any other resources within those packages, but do not provide services to the platform. You can use Blueprint to register services. Keep in mind that any service a plugin registers must exist within an exported package to be of any use.</p>"},{"location":"developers/services/backup-manager/","title":"Backup Manager","text":"<p>The <code>net.solarnetwork.node.backup.BackupManager</code> API provides SolarNode with a modular backup system composed of Backup Services that provide storage for backup data and Backup Resource Providers that contribute data to be backed up and support restoring backed up data.</p> <p>The Backup Manager coordinates the creation and restoration of backups, delegating most of its functionality to the active Backup Service. The active Backup Service can be controlled through configuration.</p> <p>The Backup Manager also supports exporting and importing Backup Archives, which are just <code>.zip</code> archives using a defined folder structure to preserve all backup resources within a single backup.</p> <p>This design of the SolarNode backup system makes it easy for SolarNode plugins to contribute resources to backups, without needing to know where or how the backup data is ultimately stored.</p> <p>What goes in a Backup?</p> <p>In SolarNode a Backup will contain all the critical settings that are unique to that node, such as:</p> <ol> <li>The node's security certificate</li> <li>SolarNetwork association details</li> <li>User accounts</li> <li>Settings</li> <li>and more</li> </ol>"},{"location":"developers/services/backup-manager/#configuration","title":"Configuration","text":"<p>The Backup Manager can be configured under the <code>net.solarnetwork.node.backup.DefaultBackupManager</code> configuration namespace:</p> Key Default Description <code>backupRestoreDelaySeconds</code> 15 A number of seconds to delay the attempt of restoring a backup, when a backup has been previously marked for restoration. This delay gives the platform time to boot up and register the backup resource providers and other services required to perform the restore. <code>preferredBackupServiceKey</code> net.solarnetwork.node.backup.FileSystemBackupService The key of the preferred (active) Backup Service to use."},{"location":"developers/services/backup-manager/#backup","title":"Backup","text":"<p>The <code>net.solarnetwork.node.backup.Backup</code> API defines a unique backup, created by a Backup Service. Backups are uniquely identified with a unique key assigned by the Backup Service that creates them.</p> <p>A <code>Backup</code> does not itself provide access to any of the resources associated with the backup. Instead, the <code>getBackupResources()</code> method of <code>BackupService</code> returns them.</p>"},{"location":"developers/services/backup-manager/#backup-archive","title":"Backup Archive","text":"<p>The Backup Manager supports exporting and importing specially formed <code>.zip</code> archives that contain a complete Backup. These archives are a convenient way to transfer settings from one node to another, and can be used to restore SolarNode on a new device.</p>"},{"location":"developers/services/backup-manager/#backup-resource","title":"Backup Resource","text":"<p>The <code>net.solarnetwork.node.backup.BackupResource</code> API defines a unique item within a Backup. A Backup Resource could be a file, a database table, or anything that can be serialized to a stream of bytes. Backup Resources are both provided by, and restored with, Backup Resource Providers so it is up to the Provider implementation to know how to generate and then restore the Resources it manages.</p>"},{"location":"developers/services/backup-manager/#backup-resource-provider","title":"Backup Resource Provider","text":"<p>The <code>net.solarnetwork.node.backup.BackupResourceProvider</code> API defines a service that can both generate and restore Backup Resources. Each implementation is identified by a unique key, typically the fully-qualified Java class name of the implementation.</p> <p>When a Backup is created, all Backup Resource Provider services registered in SolarNode will be asked to contribute their Backup Resources, using the <code>getBackupResources()</code> method.</p> <p>When a Backup is restored, Backup Resources will be passed to their associated Provider with the <code>restoreBackupResource(BackupResource)</code> method.</p>"},{"location":"developers/services/backup-manager/#backup-service","title":"Backup Service","text":"<p>The <code>net.solarnetwork.node.backup.BackupService</code> API defines the bulk of the SolarNode backup system. Each implementation is identified by a unique key, typically the fully-qualified Java class name of the implementation.</p> <p>To create a Backup, use the <code>performBackup(Iterable&lt;BackupResource&gt;)</code> method, passing in the collection of Backup Resources to include.</p> <p>To list the available Backups, use the <code>getAvailableBackups(Backup)</code> method.</p> <p>To view a single Backup, use the <code>backupForKey(String)</code> method.</p> <p>To list the resources in a Backup, use the <code>getBackupResources(Backup)</code>method.</p>"},{"location":"developers/services/backup-manager/#filesystembackupservice","title":"FileSystemBackupService","text":"<p>SolarNode provides the <code>net.solarnetwork.node.backup.FileSystemBackupService</code> default Backup Service implementation that saves Backup Archives to the node's own file system.</p>"},{"location":"developers/services/backup-manager/#s3backupservice","title":"S3BackupService","text":"<p>The <code>net.solarnetwork.node.backup.s3</code> plugin provides the <code>net.solarnetwork.node.backup.s3.S3BackupService</code> Backup Service implementation that saves all Backup data to AWS S3.</p>"},{"location":"developers/services/closeable-service/","title":"Closeable Service","text":"<p>A plugin can publish a <code>net.solarnetwork.service.CloseableService</code> and SolarNode will invoke the <code>closeService()</code> method on it when that service is destroyed. This can be useful in some situations, to make sure resources are freed when a service is no longer needed.</p> <p>Blueprint does provide the <code>destroy-method</code> stop hook that can be used in many situations, however Blueprint does not allow this in all cases. For example a <code>&lt;bean&gt;</code> nested within a <code>&lt;service&gt;</code> element does not allow a <code>destroy-method</code>:</p> <pre><code>&lt;service interface=\"com.example.MyService\"&gt;\n&lt;!-- destroy-method not allowed here: --&gt;\n&lt;bean class=\"com.example.MyComponent\"/&gt;\n&lt;/service&gt;\n</code></pre> <p>If <code>MyComponent</code> also implemented <code>CloseableService</code> then we can achieve the desired stop hook like this:</p> <pre><code>&lt;service&gt;\n&lt;interfaces&gt;\n&lt;value&gt;com.example.MyService&lt;/value&gt;\n&lt;value&gt;net.solarnetwork.service.CloseableService&lt;/value&gt;\n&lt;/interfaces&gt;\n&lt;bean class=\"com.example.MyComponent\"/&gt;\n&lt;/service&gt;\n</code></pre> <p>Note</p> <p>Note that the above example <code>CloseableService</code> is not strictly needed, as the same effect could be acheived by un-nesting the <code>&lt;bean&gt;</code> from the <code>&lt;service&gt;</code> element, like this:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\" destroy-method=\"close\"/&gt;\n&lt;service ref=\"myComponent\" interface=\"com.example.MyService\"/&gt;\n</code></pre> <p>There are situations where un-nesting is not possible, which is where <code>CloseableService</code> can be helpful.</p>"},{"location":"developers/services/datum-data-source-poll-job/","title":"Datum Data Source Poll Job","text":"<p>The <code>DatumDataSourcePollManagedJob</code> class is a Job Service implementation that can be used to let users schedule the generation of datum from a Datum Data Source. Typically this is configured as a Managed Service Factory so users can configure any number of job instances, each with their own settings.</p> <p>Here is a typical example of a <code>DatumDataSourcePollManagedJob</code>, in a fictional <code>MyDatumDataSource</code>:</p> MyDatumDataSource.javaMyDatumDataSource.properties LocalizationBlueprint XML <pre><code>package com.example;\n\nimport java.time.Instant;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport net.solarnetwork.domain.datum.DatumSamples;\nimport net.solarnetwork.node.domain.datum.EnergyDatum;\nimport net.solarnetwork.node.domain.datum.NodeDatum;\nimport net.solarnetwork.node.domain.datum.SimpleEnergyDatum;\nimport net.solarnetwork.node.service.DatumDataSource;\nimport net.solarnetwork.node.service.support.DatumDataSourceSupport;\nimport net.solarnetwork.settings.SettingSpecifier;\nimport net.solarnetwork.settings.SettingSpecifierProvider;\nimport net.solarnetwork.settings.SettingsChangeObserver;\nimport net.solarnetwork.settings.support.BasicTextFieldSettingSpecifier;\n\n/**\n * Super-duper datum data source.\n *\n * @author matt\n * @version 1.0\n */\npublic class MyDatumDataSource extends DatumDataSourceSupport\nimplements DatumDataSource, SettingSpecifierProvider, SettingsChangeObserver {\n\nprivate String sourceId;\nprivate int level;\n\n@Override\npublic Class&lt;? extends NodeDatum&gt; getDatumType() {\nreturn EnergyDatum.class;\n}\n\n@Override\npublic EnergyDatum readCurrentDatum() {\nfinal String sourceId = resolvePlaceholders(this.sourceId);\nif ( sourceId == null || sourceId.isEmpty() ) {\nreturn null;\n}\nSimpleEnergyDatum d = new SimpleEnergyDatum(sourceId, Instant.now(), new DatumSamples());\nd.setWatts(level);\nreturn d;\n}\n\n@Override\npublic void configurationChanged(Map&lt;String, Object&gt; properties) {\n// the settings have changed; do something\n}\n\n@Override\npublic String getSettingUid() {\nreturn \"com.example.MyDatumDataSource\";\n}\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nreturn Arrays.asList(new BasicTextFieldSettingSpecifier(\"sourceId\", null),\nnew BasicTextFieldSettingSpecifier(\"level\", String.valueOf(0)));\n}\n\npublic String getSourceId() {\nreturn sourceId;\n}\n\npublic void setSourceId(String sourceId) {\nthis.sourceId = sourceId;\n}\n\npublic int getLevel() {\nreturn level;\n}\n\npublic void setLevel(int level) {\nthis.level = level;\n}\n\n}\n</code></pre> <pre><code>title = Super-duper Datum Data Source\ndesc = This managed datum data source does it all.\n\nschedule.key = Schedule\nschedule.desc = The schedule to execute the job at. \\\nCan be either a number representing a frequency in &lt;b&gt;milliseconds&lt;/b&gt; \\\nor a &lt;a href=\"{0}\"&gt;cron expression&lt;/a&gt;, for example &lt;code&gt;0 * * * * *&lt;/code&gt;.\n\nsourceId.key = Source ID\nsourceId.desc = The source ID to use.\n\nlevel.key = Level\nlevel.desc = This one goes to 11.\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:osgix=\"http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\"\nxmlns:beans=\"http://www.springframework.org/schema/beans\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium/gemini-blueprint-compendium.xsd\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n&lt;!-- Service References --&gt;\n\n&lt;bean id=\"datumMetadataService\" class=\"net.solarnetwork.common.osgi.service.DynamicServiceTracker\"&gt;\n&lt;argument ref=\"bundleContext\"/&gt;\n&lt;property name=\"serviceClassName\" value=\"net.solarnetwork.node.service.DatumMetadataService\"/&gt;\n&lt;property name=\"sticky\" value=\"true\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"datumQueue\" class=\"net.solarnetwork.common.osgi.service.DynamicServiceTracker\"&gt;\n&lt;argument ref=\"bundleContext\"/&gt;\n&lt;property name=\"serviceClassName\" value=\"net.solarnetwork.node.service.DatumQueue\"/&gt;\n&lt;property name=\"sticky\" value=\"true\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"placeholderService\" class=\"net.solarnetwork.common.osgi.service.DynamicServiceTracker\"&gt;\n&lt;argument ref=\"bundleContext\"/&gt;\n&lt;property name=\"serviceClassName\" value=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n&lt;property name=\"sticky\" value=\"true\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt;\n&lt;property name=\"basenames\" value=\"com.example.MyDatumDataSource\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"jobMessageSource\" class=\"net.solarnetwork.support.PrefixedMessageSource\"&gt;\n&lt;property name=\"prefix\" value=\"datumDataSource.\"/&gt;\n&lt;property name=\"delegate\" ref=\"messageSource\"/&gt;\n&lt;/bean&gt;\n\n&lt;!-- Managed Service Factory for Datum Data Source --&gt;\n\n&lt;service interface=\"net.solarnetwork.settings.SettingSpecifierProviderFactory\"&gt;\n&lt;bean class=\"net.solarnetwork.settings.support.BasicSettingSpecifierProviderFactory\"&gt;\n&lt;property name=\"displayName\" value=\"Super-duper Datum Data Source\"/&gt;\n&lt;property name=\"factoryUid\" value=\"com.example.MyDatumDataSource\"/&gt;&lt;!-- (1)! --&gt;\n&lt;property name=\"messageSource\" ref=\"messageSource\"/&gt;\n&lt;/bean&gt;\n&lt;/service&gt;\n\n&lt;osgix:managed-service-factory factory-pid=\"com.example.MyDatumDataSource\"\nautowire-on-update=\"true\" update-method=\"configurationChanged\"&gt;\n&lt;osgix:interfaces&gt;\n&lt;beans:value&gt;net.solarnetwork.node.job.ManagedJob&lt;/beans:value&gt;\n&lt;/osgix:interfaces&gt;\n&lt;bean class=\"net.solarnetwork.node.job.SimpleManagedJob\"\ninit-method=\"serviceDidStartup\" destroy-method=\"serviceDidShutdown\"&gt;\n&lt;argument&gt;\n&lt;bean class=\"net.solarnetwork.node.job.DatumDataSourcePollManagedJob\"&gt;\n&lt;property name=\"datumMetadataService\" ref=\"datumMetadataService\"/&gt;\n&lt;property name=\"datumQueue\" ref=\"datumQueue\"/&gt;\n&lt;property name=\"datumDataSource\"&gt;\n&lt;bean class=\"com.example.MyDatumDataSource\"&gt;&lt;!-- (2)! --&gt;\n&lt;property name=\"datumMetadataService\" ref=\"datumMetadataService\"/&gt;\n&lt;property name=\"messageSource\" ref=\"jobMessageSource\"/&gt;\n&lt;property name=\"placeholderService\" ref=\"placeholderService\"/&gt;\n&lt;/bean&gt;\n&lt;/property&gt;\n&lt;/bean&gt;\n&lt;/argument&gt;\n&lt;argument value=\"0 * * * * ?\"/&gt;\n&lt;property name=\"serviceProviderConfigurations\"&gt;&lt;!-- (3)! --&gt;\n&lt;map&gt;\n&lt;entry key=\"datumDataSource\"&gt;\n&lt;bean class=\"net.solarnetwork.node.job.SimpleServiceProviderConfiguration\"&gt;\n&lt;property name=\"interfaces\"&gt;\n&lt;list&gt;\n&lt;value&gt;net.solarnetwork.node.service.DatumDataSource&lt;/value&gt;\n&lt;/list&gt;\n&lt;/property&gt;\n&lt;property name=\"properties\"&gt;\n&lt;map&gt;\n&lt;entry key=\"datumClassName\" value=\"net.solarnetwork.node.domain.datum.EnergyDatum\"/&gt;\n&lt;/map&gt;\n&lt;/property&gt;\n&lt;/bean&gt;\n&lt;/entry&gt;\n&lt;/map&gt;\n&lt;/property&gt;\n&lt;/bean&gt;\n&lt;/osgix:managed-service-factory&gt;\n\n&lt;/blueprint&gt;\n</code></pre> <ol> <li>The <code>factoryUid</code> is the same value as the <code>getSettingsUid()</code> value in <code>MyDatumDataSource.java</code></li> <li>Hiding down here is our actual data source!</li> <li>Adding a service provider configuration is optional, but registers our data source as an    OSGi service, in addition to the <code>ManagedJob</code> that the Managed Service Factory registers.</li> </ol> <p>When this plugin is deployed in SolarNode, the managed component will appear on the main Settings page and then the component settings UI will look like this:</p> <p></p>"},{"location":"developers/services/datum-data-source/","title":"Datum Data Source","text":"<p>The <code>DatumDataSource</code> API defines the primary way for plugins to generate datum instances from devices or services integrated with SolarNode, through a request-based API. The <code>MultiDatumDataSource</code> API is closely related, and allows a plugin to generate multiple datum when requested.</p> DatumDataSourceMultiDatumDataSource <pre><code>package net.solarnetwork.node.service;\n\nimport net.solarnetwork.node.domain.datum.NodeDatum;\nimport net.solarnetwork.service.Identifiable;\n\n/**\n * API for collecting {@link NodeDatum} objects from some device.\n */\npublic interface DatumDataSource extends Identifiable, DeviceInfoProvider {\n\n/**\n     * Get the class supported by this DataSource.\n     *\n     * @return class\n     */\nClass&lt;? extends NodeDatum&gt; getDatumType();\n\n/**\n     * Read the current value from the data source, returning as an unpersisted\n     * {@link NodeDatum} object.\n     *\n     * @return Datum\n     */\nNodeDatum readCurrentDatum();\n\n}\n</code></pre> <pre><code>package net.solarnetwork.node.service;\n\nimport java.util.Collection;\nimport net.solarnetwork.node.domain.datum.NodeDatum;\nimport net.solarnetwork.service.Identifiable;\n\n/**\n * API for collecting multiple {@link NodeDatum} objects from some device.\n */\npublic interface MultiDatumDataSource extends Identifiable, DeviceInfoProvider {\n\n/**\n     * Get the class supported by this DataSource.\n     *\n     * @return class\n     */\nClass&lt;? extends NodeDatum&gt; getMultiDatumType();\n\n/**\n     * Read multiple values from the data source, returning as a collection of\n     * unpersisted {@link NodeDatum} objects.\n     *\n     * @return Datum\n     */\nCollection&lt;NodeDatum&gt; readMultipleDatum();\n\n}\n</code></pre> <p>The Datum Data Source Poll Job provides a way to let users schedule the polling for datum from a data source.</p>"},{"location":"developers/services/datum-db/","title":"Datum Database","text":"<p>TODO</p>"},{"location":"developers/services/datum-queue/","title":"Datum Queue","text":"<p>SolarNode has a <code>DatumQueue</code> service that acts as a central facility for processing all <code>NodeDatum</code> captured by all data source plugins deployed in the SolarNode runtime. The queue can be configured with various filters that can augment, modify, or discard the datum. The queue buffers the datum for a short amount of time and then processes them sequentially in order of time, oldest to newest.</p> <p>Datum data sources that use the Datum Data Source Poll Job are polled for datum on a recurring schedule and those datum are then posted to and stored in SolarNetwork. Data sources can also offer datum directly to the <code>DatumQueue</code> if they emit datum based on external events. When offering datum directly, the datum can be tagged as transient and they will then still be processed by the queue but will not be posted/stored in SolarNetwork.</p> <pre><code>/**\n * Offer a new datum to the queue, optionally persisting.\n *\n * @param datum\n *        the datum to offer\n * @param persist\n *        {@literal true} to persist, or {@literal false} to only pass to\n *        consumers\n * @return {@literal true} if the datum was accepted\n */\nboolean offer(NodeDatum datum, boolean persist);\n</code></pre>"},{"location":"developers/services/datum-queue/#queue-observer","title":"Queue observer","text":"<p>Plugins can also register observers on the <code>DatumQueue</code> that are notified of each datum that gets processed. The <code>addConsumer()</code> and <code>removeConsumer()</code> methods allow you to register/deregister observers:</p> <pre><code>/**\n * Register a consumer to receive processed datum.\n *\n * @param consumer\n *        the consumer to register\n */\nvoid addConsumer(Consumer&lt;NodeDatum&gt; consumer);\n\n/**\n * De-register a previously registered consumer.\n *\n * @param consumer\n *        the consumer to remove\n */\nvoid removeConsumer(Consumer&lt;NodeDatum&gt; consumer);\n</code></pre> <p>Each observer will receive all datum, including transient datum. An example plugin that makes use of this feature is the SolarFlux Upload Service, which posts a copy of each datum to a MQTT server.</p> <p>Here is a screen shot of the datum queue settings available in the SolarNode UI:</p> <p></p>"},{"location":"developers/services/job-scheduler/","title":"Job Scheduler","text":"<p>SolarNode provides a ManagedJobScheduler service that can automatically execute jobs exported by plugins that have user-defined schedules.</p> <p>The Job Scheduler uses the Task Scheduler</p> <p>The Job Scheduler service uses the Task Scheduler internally, which means the number of jobs that can execute simultaneously will be limited by its thread pool configuration.</p>"},{"location":"developers/services/job-scheduler/#managed-jobs","title":"Managed Jobs","text":"<p>Any plugin simply needs to register a ManagedJob service for the Job Scheduler to automatically schedule and execute the job. The schedule is provided by the <code>getSchedle()</code> method, which can return a cron expression or a plain number representing a millisecond period.</p> <p>The <code>net.solarnetwork.node.job.SimpleManagedJob</code> class implements <code>ManagedJob</code> and can be used in most situations. It delegates the actual work to a <code>net.solarnetwork.node.job.JobService</code> API, discussed in the next section.</p>"},{"location":"developers/services/job-scheduler/#job-service","title":"Job Service","text":"<p>The <code>ManagedJob</code> API delegates the actual task work to a <code>JobService</code> API. The <code>executeJobService()</code> method will be invoked when the job executes.</p>"},{"location":"developers/services/job-scheduler/#example-managed-job","title":"Example Managed Job","text":"<p>Let's imagine you have a <code>com.example.Job</code> class that you would like to allow users to schedule. Your class would implement the <code>JobService</code> interface, and then you would provide a localized messages properties file and configure the service using OSGi Blueprint.</p> com.example.Job.javacom.example.Job.propertiesOSGi Blueprint <pre><code>package com.example;\n\nimport java.util.Collections;\nimport java.util.List;\nimport net.solarnetwork.node.job.JobService;\nimport net.solarnetwork.node.service.support.BaseIdentifiable;\nimport net.solarnetwork.settings.SettingSpecifier;\n\n/**\n * My super-duper job.\n */\npublic class Job exetnds BaseIdentifiable implements JobService {\n@Override\npublic String getSettingUid() {\nreturn \"com.example.job\"; // (1)!\n}\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nreturn Collections.emptyList(); // (2)!\n}\n\n@Override\npublic void executeJobService() throws Exception {\n// do great stuff here!\n}\n}\n</code></pre> <ol> <li>The setting UID will be configured in the Blueprint XML as well.</li> <li>The <code>SimpleManagedJob</code> class we'll configure in Blueprint XML will automatically    add a <code>schedule</code> setting to configure the job schedule.</li> </ol> <pre><code>title = Super-duper Job\ndesc = This job does it all.\n\nschedule.key = Schedule\nschedule.desc = The schedule to execute the job at. \\\nCan be either a number representing a frequency in &lt;b&gt;milliseconds&lt;/b&gt; \\\nor a &lt;a href=\"{0}\"&gt;cron expression&lt;/a&gt;, for example &lt;code&gt;0 * * * * *&lt;/code&gt;.\n</code></pre> <pre><code>&lt;service interface=\"net.solarnetwork.node.job.ManagedJob\"&gt;&lt;!-- (1)! --&gt;\n&lt;service-properties&gt;\n&lt;entry key=\"service.pid\" value=\"com.example.job\"/&gt;\n&lt;/service-properties&gt;\n&lt;bean class=\"net.solarnetwork.node.job.SimpleManagedJob\"&gt;&lt;!-- (2)! --&gt;\n&lt;argument&gt;\n&lt;bean class=\"com.example.Job\"&gt;\n&lt;property name=\"uid\" value=\"com.example.job\"/&gt;&lt;!-- (3)! --&gt;\n&lt;property name=\"messageSource\"&gt;\n&lt;bean class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt;\n&lt;property name=\"basenames\" value=\"com.example.Job\"/&gt;\n&lt;/bean&gt;\n&lt;/property&gt;\n&lt;/bean&gt;\n&lt;/argument&gt;\n&lt;property name=\"schedule\" value=\"0 * * * * *\"/&gt;\n&lt;/bean&gt;\n&lt;/service&gt;\n</code></pre> <ol> <li>This registers a <code>ManagedJob</code> service with the SolarNode runtime.</li> <li>The <code>SimpleManagedJob</code> class is a handy <code>ManagedJob</code> implementation. It adds a <code>schedule</code>    setting to any settings returned by the <code>JobService</code>.</li> <li>The <code>uid</code> value should match the <code>service.pid</code> used earlier, which matches the value    returned by the <code>getSettingUid()</code> method in the <code>Job</code> class.</li> </ol> <p>When this plugin is deployed in SolarNode, the component will appear on the main Settings page and offer a configurable Schedule setting, like this:</p> <p></p>"},{"location":"developers/services/placeholder-service/","title":"Placeholder Service","text":"<p>The Placeholder Service API provides components a way to resolve variables in strings, known as placeholders, whose values are managed outside the component itself. For example a datum data source plugin could use the Placeholder Service to support resolving placeholders in a configurable Source ID property.</p> <p>SolarNode provides a Placeholder Service implementation that resolves both dynamic placeholders from the Settings Database (using the setting namespace <code>placeholder</code>), and static placeholders from a configurable file or directory location.</p>"},{"location":"developers/services/placeholder-service/#use","title":"Use","text":"<p>Call the <code>resolvePlaceholders(s, parameters)</code> method to resolve all placeholders on the String <code>s</code>. The <code>parameters</code> argument can be used to provide additional placeholder values, or you can pass just pass <code>null</code> to rely solely on the placeholders available in the service already.</p>"},{"location":"developers/services/placeholder-service/#example","title":"Example","text":"<p>Here is an imaginary class that is constructed with an optional <code>PlaceholderService</code>, and then when the <code>go()</code> method is called uses that to resolve placeholders in the string <code>{building}/temp</code> and return the result:</p> <pre><code>package com.example;\n\nimport net.solarnetwork.node.service.PlaceholderService;\nimport net.solarnetwork.service.OptionalService;\n\npublic class MyComponent {\n\nprivate final OptionalService&lt;PlaceholderService&gt; placeholderService;\n\npublic MyComponent(OptionalService&lt;PlaceholderService&gt; placeholderService) {\nsuper();\nthis.placeholderService = placeholderService;\n}\n\npublic String go() {\nreturn PlaceholderService.resolvePlaceholders(placeholderService,\n\"{building}/temp\", null);\n}\n}\n</code></pre>"},{"location":"developers/services/placeholder-service/#blueprint","title":"Blueprint","text":"<p>To use the Placeholder Service in your component, add either an Optional Service or explicit reference to your plugin's Blueprint XML file like this (depending on what your plugin requires):</p> Optional ServiceExplicit Reference <pre><code>&lt;bean id=\"placeholderService\" class=\"net.solarnetwork.common.osgi.service.DynamicServiceTracker\"&gt;\n&lt;argument ref=\"bundleContext\"/&gt;\n&lt;property name=\"serviceClassName\" value=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n&lt;property name=\"sticky\" value=\"true\"/&gt;\n&lt;/bean&gt;\n</code></pre> <pre><code>&lt;reference id=\"placeholderService\" interface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n</code></pre> <p>Then inject that service into your component's <code>&lt;bean&gt;</code>, for example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;/bean&gt;\n</code></pre>"},{"location":"developers/services/placeholder-service/#configuration","title":"Configuration","text":"<p>The Placeholder Service supports the following configuration properties in the <code>net.solarnetwork.node.core</code> namespace:</p> Property Default Description <code>placeholders.dir</code> ${CONF_DIR}/placeholders.d Path to a single propertites file or to a directory of properties files to load as static placeholder parameter values when SolarNode starts up."},{"location":"developers/services/settings-db/","title":"Settings Database","text":""},{"location":"developers/services/settings-service/","title":"Settings Service","text":"<p>TODO</p>"},{"location":"developers/services/sql-database/","title":"SQL Database","text":"<p>The SolarNode runtime provides a local SQL database that is used to hold application settings, data sampled from devices, or anything really. Some data is designed to live only in this local store (such as settings) while other data eventually gets pushed up into the SolarNet cloud. This document describes the most common aspects of the local database.</p>"},{"location":"developers/services/sql-database/#database-implementation","title":"Database implementation","text":"<p>The database is provided by either the H2 or Apache Derby embedded SQL database engine.</p> <p>Note</p> <p>In SolarNodeOS the solarnode-app-db-h2 and solarnode-app-db-derby packages provide the H2 and Derby database implementations. Most modern SolarNode deployments use H2.</p> <p>Typically the database is configured to run entirely within RAM on devices that support it, and the RAM copy is periodically synced to non-volatile media so if the device restarts the persisted copy of the database can be loaded back into RAM. This pattern works well because:</p> <ol> <li>Non-volatile media access can be slow (e.g. flash memory)</li> <li>Non-volatile media can wear out over time from many writes (e.g. flash memory)</li> <li>Aside from settings, which change infrequently, most data stays locally only a     short time before getting pushed into the SolarNet cloud.</li> </ol>"},{"location":"developers/services/sql-database/#low-level-access-jdbc","title":"Low level access: JDBC","text":"<p>A standard JDBC stack is available and normal SQL queries are used to access the database. The Hikari JDBC connection pool provides a <code>javax.sql.DataSource</code> for direct JDBC access. The pool is configured by factory configuration files in the <code>net.solarnetwork.jdbc.pool.hikari</code> namespace. See the net.solarnetwork.jdbc.pool.hikari-solarnode.cfg as an example.</p> <p>To make use of the <code>DataSource</code> from a plugin using OSGi Blueprint you can declare a reference like this:</p> <pre><code>&lt;reference id=\"dataSource\" interface=\"javax.sql.DataSource\" filter=\"(db=node)\" /&gt;\n</code></pre> <p>The net.solarnetwork.node.dao.jdbc bundle publishes some other JDBC services for plugins to use, such as:</p> <ul> <li>A Spring <code>org.springframework.jdbc.core.JdbcOperations</code> for slightly higher-level JDBC access</li> <li>A Spring <code>org.springframework.transaction.PlatformTransactionManager</code> for JDBC transaction    support</li> </ul> <p>To make use of these from a plugin using OSGi Blueprint you can declare references to these APIs like this:</p> <pre><code>&lt;reference id=\"jdbcOps\" interface=\"org.springframework.jdbc.core.JdbcOperations\"\nfilter=\"(db=node)\" /&gt;\n\n&lt;reference id=\"txManager\" interface=\"org.springframework.transaction.PlatformTransactionManager\"\nfilter=\"(db=node)\" /&gt;\n</code></pre>"},{"location":"developers/services/sql-database/#high-level-access-data-access-object-dao","title":"High level access: Data Access Object (DAO)","text":"<p>The SolarNode runtime also provides some Data Access Object (DAO) services that make storing some typical data easier:</p> <ul> <li>A <code>net.solarnetwork.node.dao.SettingDao</code> for access to the Settings Database</li> <li>A <code>net.solarnetwork.node.dao.DatumDao</code> for access to the Datum Database</li> </ul> <p>To make use of these from a plugin using OSGi Blueprint you can declare references to these APIs like this:</p> <pre><code>&lt;reference id=\"settingDao\" interface=\"net.solarnetwork.node.dao.SettingDao\"/&gt;\n\n&lt;reference id=\"datumDao\" interface=\"net.solarnetwork.node.dao.DatumDao\"/&gt;\n</code></pre>"},{"location":"developers/services/task-executor/","title":"Task Executor","text":"<p>To support asynchronous task execution, SolarNode makes several thread-pool based services available to plugins:</p> <ul> <li>A <code>java.util.concurrent.Executor</code> service for standard <code>Runnable</code> task execution</li> <li>A Spring <code>TaskExecutor</code> service for <code>Runnable</code> task execution</li> <li>A Spring <code>AsyncTaskExecutor</code> service for both <code>Runnable</code> and <code>Callable</code> task execution</li> <li>A Spring <code>AsyncListenableTaskExecutor</code> service for both <code>Runnable</code>   and <code>Callable</code> task execution that supports the   <code>org.springframework.util.concurrent.ListenableFuture</code> API</li> </ul> <p>Need to schedule tasks?</p> <p>See the Task Scheduler page for information on scheduling simple tasks, or the Job Scheduler page for information on scheduling managed jobs.</p> <p>To make use of any of these services from a plugin using OSGi Blueprint you can declare a reference to them like this:</p> <pre><code>&lt;reference id=\"taskExecutor\" interface=\"java.util.concurrent.Executor\"\nfilter=\"(function=node)\"/&gt;\n\n&lt;reference id=\"taskExecutor\" interface=\"org.springframework.core.task.TaskExecutor\"\nfilter=\"(function=node)\"/&gt;\n\n&lt;reference id=\"taskExecutor\" interface=\"org.springframework.core.task.AsyncTaskExecutor\"\nfilter=\"(function=node)\"/&gt;\n\n&lt;reference id=\"taskExecutor\" interface=\"org.springframework.core.task.AsyncListenableTaskExecutor\"\nfilter=\"(function=node)\"/&gt;\n</code></pre>"},{"location":"developers/services/task-executor/#thread-pool-configuration","title":"Thread pool configuration","text":"<p>This thread pool is configured as a fixed-size pool with the number of threads set to the number of CPU cores detected at runtime, plus one. For example on a Raspberry Pi 4 there are 4 CPU cores so the thread pool would be configured with 5 threads.</p>"},{"location":"developers/services/task-scheduler/","title":"Task Scheduler","text":"<p>To support asynchronous task scheduling, SolarNode provides a Spring TaskScheduler service to plugins.</p> <p>The Job Scheduler</p> <p>For user-configurable scheduled tasks, check out the Job Scheduler service.</p> <p>To make use of any of this service from a plugin using OSGi Blueprint you can declare a reference like this:</p> <pre><code>&lt;reference id=\"taskScheduler\" interface=\"org.springframework.scheduling.TaskScheduler\"\nfilter=\"(function=node)\"/&gt;\n</code></pre>"},{"location":"developers/services/task-scheduler/#configuration","title":"Configuration","text":"<p>The Task Scheduler supports the following configuration properties in the <code>net.solarnetwork.node.core</code> namespace:</p> Property Default Description <code>jobScheduler.poolSize</code> 10 The number of threads to maintain in the job scheduler, and thus the maximum number of jobs that can run simultaneously. Must be set to 1 or higher. <code>scheduler.startupDelay</code> 180 A delay in seconds after creating the job scheduler to start triggering jobs. This can be useful to give the application time to completely initialize before starting to run jobs. <p>For example, to change the thread pool size to 20 and shorten the startup delay to 30 seconds, create an <code>/etc/solarnode/services/net.solarnetwork.node.core.cfg</code> file with the following content:</p> <pre><code>jobScheduler.poolSize = 20\nscheduler.startupDelay = 30\n</code></pre>"},{"location":"developers/settings/","title":"Settings","text":"<p>SolarNode provides a way for plugin components to describe their user-configurable properties, called settings, to the platform. SolarNode provides a web-based GUI that makes it easy for users to configure those components using a web browser. For example, here is a screen shot of the SolarNode GUI showing a form for the settings of a Database Backup component:</p> <p></p> <p>The mechanism for components to describe themselves in this way is called the Settings API. Classes that wish to participate in this system publish metadata about their configurable properties through the Settings Provider API, and then SolarNode generates a GUI form based on that metadata. Each form field in the previous example image is a Setting Specifier.</p> <p>The process is similar to the built-in Settings app on iOS: iOS applications can publish configurable property definitions and the Settings app displays a GUI that allows users to modify those properties.</p>"},{"location":"developers/settings/factory/","title":"Factory Service","text":""},{"location":"developers/settings/provider/","title":"Settings Provider","text":"<p>The <code>net.solarnetwork.settings.SettingSpecifierProvider</code> interface defines the way a class can declare themselves as a user-configurable component. The main elements of this API are:</p> <pre><code>public interface SettingSpecifierProvider {\n\n/**\n     * Get a unique, application-wide setting ID.\n     *\n     * @return unique ID\n     */\nString getSettingUid();\n\n/**\n     * Get a non-localized display name.\n     *\n     * @return non-localized display name\n     */\nString getDisplayName();\n\n/**\n     * Get a list of {@link SettingSpecifier} instances.\n     *\n     * @return list of {@link SettingSpecifier}\n     */\nList&lt;SettingSpecifier&gt; getSettingSpecifiers();\n\n}\n</code></pre> <p>The <code>getSettingUid()</code> method defines a unique ID for the configurable component. By convention the class or package name of the component (or a derivative of it) is used as the ID.</p> <p>The <code>getSettingSpecifiers()</code> method returns a list of all the configurable properties of the component, as a list of Setting Specifier instances.</p>"},{"location":"developers/settings/provider/#setting-accessors","title":"Setting accessors","text":"<p>s <pre><code>@Override\nprivate String username;\n\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;(1);\n\n// expose a \"username\" setting with a default value of \"admin\"\nresults.add(new BasicTextFieldSettingSpecifier(\"username\", \"admin\"));\n\nreturn results;\n}\n\n// settings are updated at runtime via standard setter methods\npublic void setUsername(String username) {\nthis.username = username;\n}\n</code></pre></p> <p>Setting values are treated as strings within the Settings API, but the methods associated with settings can accept any primitive or standard number type like <code>int</code> or <code>Integer</code> as well.</p> BigDecimal setting example<pre><code>@Override\nprivate BigDecimal num;\n\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;(1);\n\nresults.add(new BasicTextFieldSettingSpecifier(\"num\", null));\n\nreturn results;\n}\n\n// settings will be coerced from strings into basic types automatically\npublic void setNum(BigDecimal num) {\nthis.num = num;\n}\n</code></pre>"},{"location":"developers/settings/provider/#proxy-setting-accessors","title":"Proxy setting accessors","text":"<p>Sometimes you might like to expose a simple string setting but internally treat the string as a more complex type. For example a <code>Map</code> could be configured using a simple delimited string like <code>key1 = val1, key2 = val2</code>. For situations like this you can publish a proxy setting that manages a complex data type as a string, and en/decode the complex type in your component accessor methods.</p> Delimited string to Map setting example<pre><code>@Override\nprivate Map&lt;String, String&gt; map;\n\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;(1);\n\n// expose a \"mapping\" proxy setting for the map field\nresults.add(new BasicTextFieldSettingSpecifier(\"mapping\", null));\n\nreturn results;\n}\n\npublic void setMapping(String mapping) {\nthis.map = StringUtils.commaDelimitedStringToMap(mapping);\n}\n</code></pre>"},{"location":"developers/settings/resource-handler/","title":"Setting Resource Handler","text":"<p>The <code>net.solarnetwork.node.settings.SettingResourceHandler</code> API defines a way for a component to import and export files uploaded to SolarNode from external sources.</p> <p>A component could support importing a file using the File setting. This could be used, to provide a way of configuring the component from a configuration file, like CSV, JSON, XML, and so on. Similarly a component could support exporting a file, to generate a configuration file in another format like CSV, JSON, XML, and so on, from its current settings. For example, the Modbus Device Datum Source does exactly these things: importing and exporting a custom CSV file to make configuring the component easier.</p>"},{"location":"developers/settings/resource-handler/#importing","title":"Importing","text":"<p>The main part of the <code>SettingResourceHandler</code> API for importing files looks like this:</p> <pre><code>public interface SettingResourceHandler {\n\n/**\n     * Get a unique, application-wide setting ID.\n     *\n     * &lt;p&gt;\n     * This ID must be unique across all setting resource handlers registered\n     * within the system. Generally the implementation will also be a\n     * {@link net.solarnetwork.settings.SettingSpecifierProvider} for the same\n     * ID.\n     * &lt;/p&gt;\n     *\n     * @return unique ID\n     */\nString getSettingUid();\n\n/**\n     * Apply settings for a specific key from a resource.\n     *\n     * @param settingKey\n     *        the setting key, generally a\n     *        {@link net.solarnetwork.settings.KeyedSettingSpecifier#getKey()}\n     *        value\n     * @param resources\n     *        the resources with the settings to apply\n     * @return any setting values that should be persisted as a result of\n     *         applying the given resources (never {@literal null}\n     * @throws IOException\n     *         if any IO error occurs\n     */\nSettingsUpdates applySettingResources(String settingKey, Iterable&lt;Resource&gt; resources)\nthrows IOException;\n</code></pre> <p>The <code>getSettingUid()</code> method overlaps with the Settings Provider API, and as the comments note it is typical for a Settings Provider that publishes settings like File or Text Area to also implement <code>SettingResourceHandler</code>.</p> <p>The <code>settingKey</code> passed to the <code>applySettingResources()</code> method identifies the resource(s) being uploaded, as a single Setting Resource Handler might support multiple resources. For example a Settings Provider might publish multiple File settings, or File and Text Area settings. The <code>settingKey</code> is used to differentiate between each one.</p>"},{"location":"developers/settings/resource-handler/#importing-example","title":"Importing example","text":"<p>Imagine a component that publishes a File setting. A typical implementation of that component would look like this (this example omits some methods for brevity):</p> <pre><code>public class MyComponent implements SettingSpecifierProvider,\nSettingResourceHandler {\n\nprivate static final Logger log\n= LoggerFactory.getLogger(MyComponent.class);\n\n/** The resource key to identify the File setting resource. */\npublic static final String RESOURCE_KEY_DOCUMENT = \"document\";\n\n@Override\npublic String getSettingUid() {\nreturn \"com.example.mycomponent\";\n}\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;();\n\n// publish a File setting tied to the RESOURCE_KEY_DOCUMENT key,\n// allowing only text files to be accepted\nresults.add(new BasicFileSettingSpecifier(RESOURCE_KEY_DOCUMENT, null,\nnew LinkedHashSet&lt;&gt;(asList(\".txt\", \"text/*\")), false));\n\nreturn results;\n}\n\n@Override\npublic SettingsUpdates applySettingResources(String settingKey,\nIterable&lt;Resource&gt; resources) throws IOException {\nif ( resources == null ) {\nreturn null;\n}\nif ( RESOURCE_KEY_DOCUMENT.equals(settingKey) ) {\nfor ( Resource r : resources ) {\n// here we would do something useful with the resource... like\n// read into a string and log it\nString s = FileCopyUtils.copyToString(new InputStreamReader(\nr.getInputStream(), StandardCharsets.UTF_8));\n\nlog.info(\"Got {} resource content: {}\", settingKey, s);\n\nbreak; // only accept one file\n}\n}\nreturn null;\n}\n\n}\n</code></pre>"},{"location":"developers/settings/resource-handler/#exporting","title":"Exporting","text":"<p>The part of the Setting Resource Handler API that supports exporting setting resources looks like this:</p> <pre><code>    /**\n     * Get a list of supported setting keys for the\n     * {@link #currentSettingResources(String)} method.\n     *\n     * @return the set of supported keys\n     */\ndefault Collection&lt;String&gt; supportedCurrentResourceSettingKeys() {\nreturn Collections.emptyList();\n}\n\n/**\n     * Get the current setting resources for a specific key.\n     *\n     * @param settingKey\n     *        the setting key, generally a\n     *        {@link net.solarnetwork.settings.KeyedSettingSpecifier#getKey()}\n     *        value\n     * @return the resources, never {@literal null}\n     */\nIterable&lt;Resource&gt; currentSettingResources(String settingKey);\n</code></pre> <p>The <code>supportedCurrentResourceSettingKeys()</code> method returns a set of resource keys the component supports for exporting. The <code>currentSettingResources()</code> method returns the resources to export for a given key.</p> <p>The SolarNode GUI shows a form menu with all the available resources for all components that support the <code>SettingResourceHandler</code> API, and lets the user to download them:</p> <p></p>"},{"location":"developers/settings/resource-handler/#exporting-example","title":"Exporting example","text":"<p>Here is an example of a component that supports exporting a CSV file resource based on the component's current configuration:</p> <pre><code>public class MyComponent implements SettingSpecifierProvider,\nSettingResourceHandler {\n\n/** The setting resource key for a CSV configuration file. */\npublic static final String RESOURCE_KEY_CSV_CONFIG = \"csvConfig\";\n\nprivate int max = 1;\nprivate boolean enabled = true;\n\n@Override\npublic Collection&lt;String&gt; supportedCurrentResourceSettingKeys() {\nreturn Collections.singletonList(RESOURCE_KEY_CSV_CONFIG);\n}\n\n@Override\npublic Iterable&lt;Resource&gt; currentSettingResources(String settingKey) {\nif ( !RESOURCE_KEY_CSV_CONFIG.equals(settingKey) ) {\nreturn null;\n}\n\nStringBuilder buf = new StringBuilder();\nbuf.append(\"max,enabled\\r\\n\");\nbuf.append(max).append(',').append(enabled).append(\"\\r\\n\");\n\nreturn Collections.singleton(new ByteArrayResource(\nbuf.toString().getBytes(UTF_8), \"My Component CSV Config\") {\n\n@Override\npublic String getFilename() {\nreturn \"my-component-config.csv\";\n}\n\n});\n}\n}\n</code></pre>"},{"location":"developers/settings/singleton/","title":"Singleton Service","text":""},{"location":"developers/settings/specifier/","title":"Setting Specifier","text":"<p>The <code>net.solarnetwork.settings.SettingSpecifier</code> API defines metadata for a single configurable property in the Settings API. The API looks like this:</p> <pre><code>public interface SettingSpecifier {\n\n/**\n     * A unique identifier for the type of setting specifier this represents.\n     *\n     * &lt;p&gt;\n     * Generally this will be a fully-qualified interface name.\n     * &lt;/p&gt;\n     *\n     * @return the type\n     */\nString getType();\n\n/**\n     * Localizable text to display with the setting's content.\n     *\n     * @return the title\n     */\nString getTitle();\n\n}\n</code></pre> <p>This interface is very simple, and extended by more specialized interfaces that form more useful setting types.</p> <p>Note</p> <p>A <code>SettingSpecifier</code> instance is often referred to simply as a setting.</p> <p>Here is a view of the class hierarchy that builds off of this interface:</p> <p></p> <p>Note</p> <p>The <code>SettingSpecifier</code> API defines metadata about a configurable property, but not methods to view or change that property's value. The Settings Service provides methods for managing setting values.</p>"},{"location":"developers/settings/specifier/#settings-playpen","title":"Settings Playpen","text":"<p>The Settings Playpen plugin demonstrates most of the available setting types, and is a great way to see how the settings can be used.</p>"},{"location":"developers/settings/specifier/#text-field","title":"Text Field","text":"<p>The <code>TextFieldSettingSpecifier</code> defines a simple string-based configurable property and is the most common setting type. The setting defines a <code>key</code> that maps to a setter method on its associated component class. In the SolarNode GUI a text field is rendered as an HTML form text input, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicTextFieldSettingSpecifier</code> class provides the standard implementation of this API. A standard text field setting is created like this:</p> <pre><code>new BasicTextFieldSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\");\n\n// or without any default value\nnew BasicTextFieldSettingSpecifier(\"myProperty\", null);\n</code></pre> <p>Tip</p> <p>Setting values are generally treated as strings within the Settings API, however other basic data types such as integers and numbers can be used as well. You can also publish a \"proxy\" setting that manages a complex data type as a string, and en/decode the complex type in your component accessor methods.</p> <p>For example a <code>Map&lt;String, String&gt;</code> setting could be published as a text field setting that en/decodes the <code>Map</code> into a delimited string value, for example <code>name=Test, color=red</code>.</p>"},{"location":"developers/settings/specifier/#secure-text-field","title":"Secure Text Field","text":"<p>The <code>BasicTextFieldSettingSpecifier</code> can also be used for \"secure\" text fields where the field's content is obscured from view. In the SolarNode GUI a secure text field is rendered as an HTML password form input like this:</p> <p></p> <p>A standard secure text field setting is created by passing a third <code>true</code> argument, like this:</p> <pre><code>new BasicTextFieldSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\", true);\n\n// or without any default value\nnew BasicTextFieldSettingSpecifier(\"myProperty\", null, true);\n</code></pre>"},{"location":"developers/settings/specifier/#title","title":"Title","text":"<p>The <code>TitleSettingSpecifier</code> defines a simple read-only string-based configurable property. The setting defines a <code>key</code> that maps to a setter method on its associated component class. In the SolarNode GUI the default value is rendered as plain text, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicTitleSettingSpecifier</code> class provides the standard implementation of this API. A standard title setting is created like this:</p> <pre><code>new BasicTitleSettingSpecifier(\"status\", \"Status is good.\", true);\n</code></pre>"},{"location":"developers/settings/specifier/#html-title","title":"HTML Title","text":"<p>The <code>TitleSettingSpecifier</code> supports HTML markup. In the SolarNode GUI the default value is rendered directly into HTML, like this:</p> <p></p> <pre><code>// pass `true` as the 4th argument to enable HTML markup in the status value\nnew BasicTitleSettingSpecifier(\"status\", \"Status is &lt;b&gt;good&lt;/b&gt;.\", true, true);\n</code></pre>"},{"location":"developers/settings/specifier/#text-area","title":"Text Area","text":"<p>The <code>TextAreaSettingSpecifier</code> defines a simple string-based configurable property for a larger text value, loaded as an external file using the SettingResourceHandler API. In the SolarNode GUI a text area is rendered as an HTML form text area with an associated button to upload the content, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicTextAreaSettingSpecifier</code> class provides the standard implementation of this API. A standard text field setting is created like this:</p> <pre><code>new BasicTextAreaSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\");\n\n// or without any default value\nnew BasicTextAreaSettingSpecifier(\"myProperty\", null);\n</code></pre>"},{"location":"developers/settings/specifier/#direct-text-area","title":"Direct Text Area","text":"<p>The <code>BasicTextAreaSettingSpecifier</code> can also be used for \"direct\" text areas where the field's content is not uploaded as an external file. In the SolarNode GUI a direct text area is rendered as an HTML form text area, like this:</p> <p></p> <p>A standard direct text area setting is created by passing a third <code>true</code> argument, like this:</p> <pre><code>new BasicTextAreaSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\", true);\n\n// or without any default value\nnew BasicTextAreaSettingSpecifier(\"myProperty\", null, true);\n</code></pre>"},{"location":"developers/settings/specifier/#toggle","title":"Toggle","text":"<p>The <code>ToggleSettingSpecifier</code> defines a boolean configurable property. In the SolarNode GUI a toggle setting is rendered as an HTML form button, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicToggleSettingSpecifier</code> class provides the standard implementation of this API. A standard toggle setting is created like this:</p> <pre><code>new BasicToggleSettingSpecifier(\"enabled\", false); // default \"off\"\n\nnew BasicToggleSettingSpecifier(\"enabled\", true);  // default \"on\"\n</code></pre>"},{"location":"developers/settings/specifier/#slider","title":"Slider","text":"<p>The <code>SliderSettingSpecifier</code> defines a number-based configuration property with minimum and maximum values enforced, and a step limit. In the SolarNode GUI a slider is rendered as an HTML widget, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicSliderSettingSpecifier</code> class provides the standard implementation of this API. A standard Slider setting is created like this:</p> <pre><code>// no default value, range between 0-11 in 0.5 increments\nnew BasicSliderSettingSpecifier(\"volume\", null, 0.0, 11.0, 0.5);\n\n// default value 5.0, range between 0-11 in 0.5 increments\nnew BasicSliderSettingSpecifier(\"volume\", 5.0, 0.0, 11.0, 0.5);\n</code></pre>"},{"location":"developers/settings/specifier/#radio-group","title":"Radio Group","text":"<p>The <code>RadioGroupSettingSpecifier</code> defines a configurable property that accepts a single value from a fixed set of possible values. In the SolarNode GUI a radio group is rendered as a set of HTML radio input form fields, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicRadioGroupSettingSpecifier</code> class provides the standard implementation of this API. A standard RadioGroup setting is created like this:</p> <pre><code>String[] vals = new String[] {\"a\", \"b\", \"c\"};\nString[] labels = new Strign[] {\"One\", \"Two\", \"Three\"};\nMap&lt;String, String&gt; radioValues = new LinkedHashMap&lt;&gt;(3);\nfor ( int i = 0; i &lt; vals.length; i++ ) {\nradioValues.put(vals[i], labels[i]);\n}\nBasicRadioGroupSettingSpecifier radio =\nnew BasicRadioGroupSettingSpecifier(\"option\", vals[0]);\nradio.setValueTitles(radioValues);\n</code></pre>"},{"location":"developers/settings/specifier/#multi-value","title":"Multi-value","text":"<p>The <code>MultiValueSettingSpecifier</code> defines a configurable property that accepts a single value from a fixed set of possible values. In the SolarNode GUI a multi-value setting is rendered as an HTML select form field, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicMultiValueSettingSpecifier</code> class provides the standard implementation of this API. A standard MultiValue setting is created like this:</p> <pre><code>String[] vals = new String[] {\"a\", \"b\", \"c\"};\nString[] labels = new Strign[] {\"Option 1\", \"Option 2\", \"Option 3\"};\nMap&lt;String, String&gt; radioValues = new LinkedHashMap&lt;&gt;(3);\nfor ( int i = 0; i &lt; vals.length; i++ ) {\nradioValues.put(vals[i], labels[i]);\n}\nBasicMultiValueSettingSpecifier menu = new BasicMultiValueSettingSpecifier(\"option\",\nvals[0]);\nmenu.setValueTitles(menuValues);\n</code></pre>"},{"location":"developers/settings/specifier/#file","title":"File","text":"<p>The <code>FileSettingSpecifier</code> defines a file-based resource property, loaded as an external file using the SettingResourceHandler API. In the SolarNode GUI a file setting is rendered as an HTML file input, like this:</p> <p></p> <p>The <code>net.solarnetwork.node.settings.support.BasicFileSettingSpecifier</code> class provides the standard implementation of this API. A standard file setting is created like this:</p> <pre><code>// a single file only, no default content\nnew BasicFileSettingSpecifier(\"document\", null,\nnew LinkedHashSet&lt;&gt;(Arrays.asList(\".txt\", \"text/*\")), false);\n\n// multiple files allowed, no default content\nnew BasicFileSettingSpecifier(\"document-list\", null,\nnew LinkedHashSet&lt;&gt;(Arrays.asList(\".txt\", \"text/*\")), true);\n</code></pre>"},{"location":"developers/settings/specifier/#dynamic-list","title":"Dynamic List","text":"<p>A Dynamic List setting allows the user to manage a list of homogeneous items, adding or subtracting items as desired. The items can be literals like strings, or arbitrary objects that define their own settings. In the SolarNode GUI a dynamic list setting is rendered as a pair of HTML buttons to remove and add items, like this:</p> <p></p> <p>A Dynamic List is often backed by a Java <code>Collection</code> or array in the associated component. In addition a special size-adjusting accessor method is required, named after the setter method with <code>Count</code> appended. SolarNode will use this accessor to request a specific size for the dynamic list.</p> Array-backed dynamic list accessorsList-backed dynamic list accessors <pre><code>private String[] names = new String[0];\n\npublic String[] getNames() {\nreturn names;\n}\n\npublic void setNames(String[] names) {\nthis.names = names;\n}\n\npublic int getNamesCount() {\nString[] l = getNames();\nreturn (l == null ? 0 : l.length);\n}\n\npublic void setNamesCount(int count) {\nsetNames(ArrayUtils.arrayOfLength(\ngetNames(), count, String.class, String::new));\n}\n</code></pre> <pre><code>private List&lt;String&gt; names = new ArrayList&lt;&gt;();\n\npublic List&lt;String&gt; getNames() {\nreturn names;\n}\n\npublic void setNames(List&lt;String&gt; names) {\nthis.names = names;\n}\n\npublic int getNamesCount() {\nList&lt;String&gt; l = getNames();\nreturn (l == null ? 0 : l.size());\n}\n\npublic void setNamesCount(int count) {\nif ( count &lt; 0 ) {\ncount = 0;\n}\nList&lt;String&gt; l = getNames();\nint lCount = (l == null ? 0 : l.size());\nwhile ( lCount &gt; count ) {\nl.remove(l.size() - 1);\nlCount--;\n}\nif ( l == null &amp;&amp; count &gt; 0 ) {\nl = new ArrayList&lt;&gt;();\nsetNames(l);\n}\nwhile ( lCount &lt; count ) {\nl.add(\"\");\nlCount++;\n}\n}\n</code></pre> <p>The <code>SettingUtils.dynamicListSettingSpecifier()</code> method simplifies the creation of a <code>GroupSettingSpecifier</code> that represents a dynamic list (the examples in the following sections demonstrate this).</p>"},{"location":"developers/settings/specifier/#simple-dynamic-list","title":"Simple Dynamic List","text":"<p>A simple Dynamic List is a dynamic list of string or number values.</p> <p></p> <pre><code>private String[] names = new String[0];\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;();\n\n// turn a list of strings into a Group of TextField settings\nGroupSettingSpecifier namesList = SettingUtils.dynamicListSettingSpecifier(\n\"names\", asList(names), (String value, int index, String key) -&gt;\nsingletonList(new BasicTextFieldSettingSpecifier(key, null)));\nresults.add(namesList);\n\nreturn results;\n}\n</code></pre>"},{"location":"developers/settings/specifier/#complex-dynamic-list","title":"Complex Dynamic List","text":"<p>A complex Dynamic List is a dynamic list of arbitrary object values. The main difference in terms of the necessary settings structure required, compared to a Simple Dynamic List, is that a group-of-groups is used.</p> <p></p> Complex data classDynamic List setting <pre><code>public class Person {\nprivate String firstName;\nprivate String lastName;\n\n// generate list of settings for a Person, nested under some prefix\npublic List&lt;SettingSpecifier&gt; settings(String prefix) {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;(2);\nresults.add(new BasicTextFieldSettingSpecifier(prefix + \"firstName\", null));\nresults.add(new BasicTextFieldSettingSpecifier(prefix + \"lastName\", null));\nreturn results;\n}\n\npublic void setFirstName(String firstName) {\nthis.firstName = firstName;\n}\n\npublic void setLastName(String lastName) {\nthis.lastName = lastName;\n}\n}\n</code></pre> <pre><code>private Person[] people = new Person[0];\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;();\n\n// turn a list of People into a Group of Group settings\nGroupSettingSpecifier peopleList = SettingUtils.dynamicListSettingSpecifier(\n\"people\", asList(people), (Person value, int index, String key) -&gt;\nsingletonList(new BasicGroupSettingSpecifier(\nvalue.settings(key + \".\"))));\nresults.add(peopleList);\n\nreturn results;\n}\n</code></pre>"},{"location":"users/","title":"User Guide","text":"<p>This section of the handbook is geared towards users who will be deploying and managing one or more SolarNode devices.</p> <p>See the Getting Started page to learn how to:</p> <ul> <li>get SolarNode running on a device, like a Raspberry Pi</li> <li>associate your SolarNode with your SolarNetwork account</li> </ul> <p>See the Setup App section to learn how to configure SolarNode.</p>"},{"location":"users/configuration/","title":"Configuration","text":"<p>Some SolarNode components can be configured from properties files. This type of configuration is meant to be changed just once, when a SolarNode is first deployed, to alter some default configuration value.</p> <p>Not to be confused with Settings</p> <p>This type of configuration differs from what the Settings page in the Setup App provides a UI managing. This configuration might be created by system administrators when creating a custom SolarNodeOS image for their needs, while Settings are meant to be managed by end users.</p> <p>Configuration properties files are read from the <code>/etc/solarnode/services</code> directory and named like <code>NAMESPACE.cfg</code> , where <code>NAMESPACE</code> represents a configuration namespace.</p> <p>Configuration location</p> <p>The <code>/etc/solarnode/services</code> location is the default location in SolarNodeOS. It might be another location in other SolarNode deployments.</p>"},{"location":"users/configuration/#example","title":"Example","text":"<p>Imagine a component uses the configuration namespace <code>com.example.service</code> and supports a configurable property named <code>max-threads</code> that accepts an integer value you would like to configure as <code>4</code>. You would create a <code>com.example.service.cfg</code> file like:</p> /etc/solarnode/services/com.example.service.cfg<pre><code>max-threads = 4\n</code></pre>"},{"location":"users/getting-started/","title":"Getting Started","text":"<p>This section describes how to get SolarNode running on a device. You will need to configure your device as a SolarNode and associate your SolarNode with SolarNetwork.</p> <p>Tip</p> <p>You might find it helpful to read through this entire guide before jumping in. There are screen shots and tips provided to help you along the way.</p>"},{"location":"users/getting-started/#get-your-device-ready-to-use","title":"Get your device ready to use","text":"<p>SolarNode can run on a variety of devices. To get started using SolarNode, you must download the appropriate SolarNodeOS image for your device. SolarNodeOS is a complete operating system tailor made for SolarNode.  Choose the SolarNodeOS image for the device you want to run SolarNode on and then copy that image to your device media (typically an SD card).</p>"},{"location":"users/getting-started/#choose-your-device","title":"Choose your device","text":"Raspberry PiOrange PiSomething Else <p>The Raspberry Pi is the best supported option for general SolarNode deployments. Models 3 or later, Compute Module 3 or later, and Zero 2 W or later are supported. Use a tool like Etcher or Raspberry Pi Imager to copy the image to an SD card (minimum size is 2 GB, 4 GB recommended).</p> <p> Download SolarNodeOS for Raspberry Pi</p> <p>The Orange Pi models Zero and Zero Plus are supported. Use a tool like Etcher to copy the image to an SD card (minimum size is 1 GB, 4 GB recommended).</p> <p> Download SolarNodeOS for Orange Pi</p> <p>Looking for SolarNodeOS for a device not listed here? Reach out to us through email or Slack to see if we can help!</p>"},{"location":"users/getting-started/#configure-your-network","title":"Configure your network","text":"<p>SolarNode needs a network connection. If your device has an ethernet port, that is the most reliable way to get started: just plug in your ethernet cable and off you go!</p> <p>If you want to use WiFi, or would like more detailed information about SolarNode's networking options, see the Networking sections.</p>"},{"location":"users/getting-started/#power-it-on","title":"Power it on","text":"<p>Insert your SD card (or other device media) into your device, and power it on. While it starts up, proceed with the next steps.</p>"},{"location":"users/getting-started/#associate-your-solarnode-with-solarnetwork","title":"Associate your SolarNode with SolarNetwork","text":"<p>Every SolarNode must be associated (registered) with a SolarNetwork account. To associate a SolarNode, you must:</p> <ol> <li>Log into SolarNetwork</li> <li>Generate an invitation for a new SolarNode</li> <li>Accept the invitation on SolarNode</li> </ol>"},{"location":"users/getting-started/#log-into-solarnetwork","title":"Log into SolarNetwork","text":"<p>If you do not already have a SolarNetwork account, register for one and then log in.</p>"},{"location":"users/getting-started/#generate-a-solarnode-invitation","title":"Generate a SolarNode invitation","text":"<p>Click on the My Nodes link. You will see an Invite New SolarNode button, like this:</p> <p></p> <p>Click the Invite New SolarNode button, then fill in and submit the form that appears and select your time zone by clicking on the world map:</p> <p></p> <p>The generated SolarNode invitation will appear next.</p> <p></p> <p>Select and copy the entire invitation. You will need to paste that into the SolarNode setup screen in the next section.</p>"},{"location":"users/getting-started/#accept-the-invitation-on-solarnode","title":"Accept the invitation on SolarNode","text":"<p>Open the SolarNode Setup app in your browser. The URL to use might be http://solarnode/ or it might be an IP address like <code>http://192.168.1.123</code>. See the Networking section for more information. You will be greeted with an invitation acceptance form into which you can paste the invitation you generated in SolarNetwork. The acceptance process goes through the following steps:</p> <ol> <li>Submit the invitation in the acceptance form</li> <li>Preview the invitation details</li> <li>Confirm the invitation</li> </ol> Acceptance formPreviewConfirmComplete <p>First you submit the invitation in the acceptance form.</p> <p></p> <p>Next you preview the invitation details.</p> <p>Note</p> <p>The expected SolarNetwork Service value shown in this step will be <code>in.solarnetwork.net</code>.</p> <p></p> <p>Finally, confirm the invitation. This step contacts SolarNetwork and completes the association process.</p> <p>Warning</p> <p>Ensure you provide a Certificate Password on this step, so SolarNetwork can generate a security certificate for your SolarNode.</p> <p></p> <p>When these steps are completed, SolarNetwork will have assigned your SolarNode a unique identifier known as your Node ID. A randomly generated SolarNode login password will have been generated; you are given the opportunity to easily change that if you prefer.</p> <p></p>"},{"location":"users/getting-started/#next-steps","title":"Next steps","text":"<p>Learn more about the SolarNode Setup app.</p>"},{"location":"users/logging/","title":"Logging","text":"<p>Logging in SolarNode is configured in the <code>/etc/solarnode/log4j2.xml</code> file, which is in the log4j configuration format. The default configuration in SolarNodeOS sets the overall verbosity to <code>INFO</code> and logs to a temporary storage area <code>/run/solarnode/log/solarnode.log</code>.</p>"},{"location":"users/logging/#logging-concepts","title":"Logging concepts","text":"<p>Log messages have the following general properties:</p> Component Example Description Timestamp <code>2022-03-15 09:05:37,029</code> The date/time the message was generated. Note the format of the timestamp depends on the logging configuration; the SolarNode default is shown in this example. Level <code>INFO</code> The severity/verbosity of the message (as determined by the developer). This is an enumeration, and from least-to-most severe: <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>.  The level of a given logger allows messages with that level or higher to be logged, while lower levels are skipped. The default SolarNode configuration sets the overal level to <code>INFO</code>, so <code>TRACE</code> and <code>DEBUG</code> messages are not logged. Logger <code>ModbusDatumDataSource</code> A category or namespace associated with the message. Most commonly these equate to Java class names, but can be any value and is determined by the developer. Periods in the logger name act as a delimiter, forming a hierarchy that can be tuned to log at different levels. For example, given the default <code>INFO</code> level, configuring the <code>net.solarnetwork.node.io.modbus</code> logger to <code>DEBUG</code> would turn on debug-level logging for all loggers in the Modbus IO namespace. Note that the default SolarNode configuration logs just a fixed number of the last characters of the logger name. This can be changed in the configuration to log more (or all) of the name, as desired. Message <code>Error reading from device.</code> The message itself, determined by the developer. Exception Some messages include an exception stack trace, which shows the runtime call tree where the exception occurred."},{"location":"users/logging/#logger-namespaces","title":"Logger namespaces","text":"<p>The Logger component outlined in the previous section allows a lot of flexibility to configure what gets logged in SolarNode. Setting the level on a given namespace impacts that namespace as well as all namespaces beneath it, meaning all other loggers that share the same namespace prefix.</p> <p>For example, imagine the following two loggers exist in SolarNode:</p> <ul> <li><code>net.solarnetwork.node.io.modbus.serial.SerialModbusNetwork</code></li> <li><code>net.solarnetwork.node.io.modbus.util.ModbusUtils</code></li> </ul> <p>Given the default configuration sets the default level to <code>INFO</code>, we can turn in <code>DEBUG</code> logging for both of these by adding a <code>&lt;Logger&gt;</code> line like the following within the <code>&lt;Loggers&gt;</code> element:</p> <pre><code>&lt;Logger name=\"net.solarnetwork.node.io.modbus\" level=\"debug\"/&gt;\n</code></pre> <p>That turns on <code>DEBUG</code> for both loggers because they are both children of the <code>net.solarnetwork.node.io.modbus</code> namespace. We could turn on <code>TRACE</code> logging for one of them like this:</p> <pre><code>&lt;Logger name=\"net.solarnetwork.node.io.modbus\"        level=\"debug\"/&gt;\n&lt;Logger name=\"net.solarnetwork.node.io.modbus.serial\" level=\"trace\"/&gt;\n</code></pre> <p>That would also turn on <code>TRACE</code> for any other loggers in the <code>net.solarnetwork.node.io.modbus.serial</code> namespace. You can limit the configuration all the way down to a full logger name if you like, for example:</p> <pre><code>&lt;Logger name=\"net.solarnetwork.node.io.modbus\"                            level=\"debug\"/&gt;\n&lt;Logger name=\"net.solarnetwork.node.io.modbus.serial.SerialModbusNetwork\" level=\"trace\"/&gt;\n</code></pre>"},{"location":"users/logging/#logging-ui","title":"Logging UI","text":"<p>The SolarNode UI supports configuring logger levels dynamically, without having to change the logging configuration file. See the Setup App / Settings / Logging page for more information.</p>"},{"location":"users/logging/#storage-constraints","title":"Storage constraints","text":"<p>The default SolarNode configuration automatically rotates log files based on size, and limits the number of historic log files kept around, to that its associated storage space is not filled up. When a log file reaches the file limit, it is renamed to include a <code>-i.log</code> suffix, where <code>i</code> is an offset from the current log. The default configuration sets the maximum log size to 1 MB and limits the number of historic files to 3.</p> <p>You can also adjust how much history is saved by tweaking the <code>&lt;SizeBasedTriggeringPolicy&gt;</code> and <code>&lt;DefaultRolloverStrategy&gt;</code> configuration. For example to change to a limit of 9 historic files of at most 5 MB each, the configuration would look like this:</p> <pre><code>&lt;Policies&gt;\n&lt;SizeBasedTriggeringPolicy size=\"5 MB\"/&gt;\n&lt;/Policies&gt;\n&lt;DefaultRolloverStrategy max=\"9\"/&gt;\n</code></pre>"},{"location":"users/logging/#persistent-logging","title":"Persistent logging","text":"<p>By default SolarNode logs to temporary (RAM) storage that is discarded when the node reboots. The configuration can be changed so that logs are written directly to persistent storage if you would like to have the logs persisted across reboots, or would like to preserve more log history than can be stored in the temporary storage area.</p> <p>To make this change, update the <code>&lt;RollingFile&gt;</code> element's <code>fileName</code> and/or <code>filePattern</code> attributes to point to a persistent filesystem. SolarNode already has write permission to the <code>/var/lib/solarnode/var</code> directory, so an easy location to use is <code>/var/lib/solarnode/var/log</code>, like this:</p> <pre><code>&lt;RollingFile name=\"File\"\nimmediateFlush=\"false\"\nfileName=\"/var/lib/solarnode/var/log/solarnode.log\"\nfilePattern=\"/var/lib/solarnode/var/log/solarnode-%i.log\"&gt;\n</code></pre> <p>Warning</p> <p>This configuration can add a lot of stress to the node's storage medium, and may shorten its useful life. Consumer-grade SD cards in particular can fail quickly if SolarNode is writting a lot of information, such as verbose logging. Use of this configuration should be used with caution.</p>"},{"location":"users/logging/#logging-example-split-across-multiple-files","title":"Logging example: split across multiple files","text":"<p>Sometimes it can be useful to turn on verbose logging for some area of SolarNode, but have those messages go to a different file so they don't clog up the main <code>solarnode.log</code> file. This can be done by configuring additional appender configurations.</p> <p>The following example logging configuration creates the following log files:</p> <ul> <li><code>/var/log/solarnode/solarnode.log</code> - the main log</li> <li><code>/var/log/solarnode/filter.log</code> - filter logging</li> <li><code>/var/log/solarnode/mqtt-solarin.log</code> - MQTT wire logging to SolarIn</li> <li><code>/var/log/solarnode/mqtt-solarflux.log</code> - MQTT wire logging to SolarFlux</li> </ul> <p>First you must create the <code>/var/log/solarnode</code> directory and give SolarNode permission to write there:</p> <pre><code>sudo mkdir /var/log/solarnode\nsudo chgrp solar /var/log/solarnode\nsudo chmod g+w /var/log/solarnode\n</code></pre> <p>Then edit the <code>/etc/solarnode/log4j2.xml</code> file to hold the following (adjust according to your needs):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Configuration status=\"WARN\"&gt;\n&lt;Appenders&gt;\n&lt;RollingFile name=\"File\"\nimmediateFlush=\"true\"\nfileName=\"/var/log/solarnode/solarnode.log\"\nfilePattern=\"/var/log/solarnode/solarnode-%i.log\"&gt;&lt;!-- (1)! --&gt;\n&lt;PatternLayout pattern=\"%d{DEFAULT} %-5p %40.40c; %msg%n\"/&gt;\n&lt;Policies&gt;\n&lt;SizeBasedTriggeringPolicy size=\"5 MB\"/&gt;\n&lt;/Policies&gt;\n&lt;DefaultRolloverStrategy max=\"9\"/&gt;\n&lt;/RollingFile&gt;\n&lt;RollingFile name=\"Filter\"\nimmediateFlush=\"false\"\nfileName=\"/var/log/solarnode/filter.log\"\nfilePattern=\"/var/log/solarnode/filter-%i.log\"&gt;&lt;!-- (2)! --&gt;\n&lt;PatternLayout pattern=\"%d{DEFAULT} %-5p %40.40c; %msg%n\"/&gt;\n&lt;Policies&gt;\n&lt;SizeBasedTriggeringPolicy size=\"10 MB\"/&gt;\n&lt;/Policies&gt;\n&lt;DefaultRolloverStrategy max=\"9\"/&gt;\n&lt;/RollingFile&gt;\n&lt;RollingFile name=\"MQTT\"\nimmediateFlush=\"false\"\nfileName=\"/var/log/solarnode/mqtt.log\"\nfilePattern=\"/var/log/solarnode/mqtt-%i.log\"&gt;&lt;!-- (3)! --&gt;\n&lt;PatternLayout pattern=\"%d{DEFAULT} %-5p %40.40c; %msg%n\"/&gt;\n&lt;Policies&gt;\n&lt;SizeBasedTriggeringPolicy size=\"10 MB\"/&gt;\n&lt;/Policies&gt;\n&lt;DefaultRolloverStrategy max=\"9\"/&gt;\n&lt;/RollingFile&gt;\n&lt;RollingFile name=\"Flux\"\nimmediateFlush=\"false\"\nfileName=\"/var/log/solarnode/flux.log\"\nfilePattern=\"/var/log/solarnode/flux-%i.log\"&gt;&lt;!-- (4)! --&gt;\n&lt;PatternLayout pattern=\"%d{DEFAULT} %-5p %40.40c; %msg%n\"/&gt;\n&lt;Policies&gt;\n&lt;SizeBasedTriggeringPolicy size=\"10 MB\"/&gt;\n&lt;/Policies&gt;\n&lt;DefaultRolloverStrategy max=\"9\"/&gt;\n&lt;/RollingFile&gt;\n&lt;/Appenders&gt;\n&lt;Loggers&gt;\n&lt;Logger name=\"org.eclipse.gemini.blueprint.blueprint.container.support\" level=\"warn\"/&gt;\n&lt;Logger name=\"org.eclipse.gemini.blueprint.context.support\" level=\"warn\"/&gt;\n&lt;Logger name=\"org.eclipse.gemini.blueprint.service.importer.support\" level=\"warn\"/&gt;\n&lt;Logger name=\"org.springframework.beans.factory\" level=\"warn\"/&gt;\n\n&lt;Logger name=\"net.solarnetwork.node.datum.filter\" level=\"trace\" additivity=\"false\"&gt;\n&lt;AppenderRef ref=\"Filter\"/&gt;&lt;!-- (5)! --&gt;\n&lt;/Logger&gt;\n\n&lt;Logger name=\"net.solarnetwork.mqtt.queue\" level=\"trace\" additivity=\"false\"&gt;\n&lt;AppenderRef ref=\"MQTT\"/&gt;\n&lt;/Logger&gt;\n\n&lt;Logger name=\"net.solarnetwork.mqtt.influx\" level=\"trace\" additivity=\"false\"&gt;\n&lt;AppenderRef ref=\"Flux\"/&gt;\n&lt;/Logger&gt;\n\n&lt;Root level=\"info\"&gt;\n&lt;AppenderRef ref=\"File\"/&gt;&lt;!-- (6)! --&gt;\n&lt;/Root&gt;\n&lt;/Loggers&gt;\n&lt;/Configuration&gt;\n</code></pre> <ol> <li>The <code>File</code> appender is the \"main\" application log where most logs should go.</li> <li>The <code>Filter</code> appender is where we want <code>net.solarnetwork.node.datum.filter</code> messages to go.</li> <li>The <code>MQTT</code> appender is where we want <code>net.solarnetwork.mqtt.queue</code> messages to go.</li> <li>The <code>Flux</code> appender is where we want <code>net.solarnetwork.mqtt.influx</code> messages to go.</li> <li>Here we include <code>additivity=\"false\"</code> and add the <code>&lt;AppenderRef&gt;</code> element that refereneces    the specific appender name we want the log messages to go to. The <code>additivity=false</code> attribute    means the log messages will only go to the <code>Filter</code> appender, instead of also going to    the root-level <code>File</code> appender.</li> <li>The root-level appender is the \"default\" destination for log messages, unless overridden    by a specific appender like we did for the <code>Filter</code>, <code>MQTT</code>, and <code>Flux</code> appenders above.</li> </ol>"},{"location":"users/logging/#separate-file-configuration-notes","title":"Separate file configuration notes","text":"<p>The various <code>&lt;AppenderRef&gt;</code> elements configure the appender name to write the messages to.</p> <p>The various <code>additivity=\"false\"</code> attributes disable appender additivity which means the log message will only be written to one appender, instead of being written to all configured appenders in the hierarchy (for example the root-level appender).</p> <p>The <code>immediateFlush=\"false\"</code> turns on buffered logging, which means log messages are buffered in RAM before being flushed to disk. This is more forgiving to the disk, at the expense of a delay before the messages appear.</p>"},{"location":"users/logging/#enable-mqtt-wire-logging","title":"Enable MQTT wire logging","text":"<p>MQTT wire logging means the raw MQTT packets send and received over MQTT connections will be logged in an easy-to-read but very verbose format. For the MQTT wire logging to be enabled, it must be activated with a special configuration file. Create the <code>/etc/solarnode/services/net.solarnetwork.common.mqtt.netty.cfg</code> file with this content:</p> <pre><code>wireLogging = true\n</code></pre>"},{"location":"users/logging/#mqtt-wire-log-namespace","title":"MQTT wire log namespace","text":"<p>MQTT wire logs use a namespace prefix <code>net.solarnetwork.mqtt.</code> followed by the connection's host name or IP address and port. For example SolarIn messages would use <code>net.solarnetwork.mqtt.queue.solarnetwork.net:8883</code> and SolarFlux messages would use <code>net.solarnetwork.mqtt.influx.solarnetwork.net:8884</code>.</p>"},{"location":"users/networking/","title":"Networking","text":"<p>SolarNode will attempt to automatically configure networking access from a local DHCP server. For many deployments the local network router is the DHCP server. SolarNode will identify itself with the name <code>solarnode</code>, so in many cases you can reach the SolarNode setup app at http://solarnode/.</p>"},{"location":"users/networking/#finding-solarnodes-network-address","title":"Finding SolarNode's network address","text":"<p>To find what network address SolarNode is using, you have a few options:</p>"},{"location":"users/networking/#consult-your-network-router","title":"Consult your network router","text":"<p>Your local network router is very likely to have a record of SolarNode's network connection. Log into the router's management UI and look for a device named <code>solarnode</code>.</p>"},{"location":"users/networking/#connect-a-keyboard-and-screen","title":"Connect a keyboard and screen","text":"<p>If your SolarNode supports connecting a keyboard and screen, you can log into the SolarNode command line console and run <code>ip -br addr</code> to print out a brief summary of the current networking configuration:</p> <pre><code>$ ip -br addr\n\nlo               UNKNOWN        127.0.0.1/8 ::1/128\neth0             UP             192.168.0.254/24 fe80::e65f:1ff:fed1:893c/64\nwlan0            DOWN\n</code></pre> <p>In the previous output, SolarNode has an ethernet device <code>eth0</code> with a network address <code>192.168.0.254</code> and a WiFi device <code>wlan0</code> that is not connected. You could reach that SolarNode at <code>http://192.168.0.254/</code>.</p> <p>Tip</p> <p>You can get more details by running <code>ip addr</code> (without the <code>-br</code> argument).</p>"},{"location":"users/networking/#wifi","title":"WiFi","text":"<p>If your device will use WiFi for network access, you will need to configure the network name and credentials to use. You can do that by creating a <code>wpa_supplicant.conf</code> file on the SolarNodeOS media (typically an SD card). For Raspberry Pi media, you can mount the SD card on your computer and it will mount the appropriate drive for you.</p> <p></p> <p>Once mounted use your favorite text editor to create a <code>wpa_supplicant.conf</code> file with content like this:</p> <pre><code>country=nz\nnetwork={\n    ssid=\"wifi network name here\"\n    psk=\"wifi password here\"\n}\n</code></pre> <p>Change the <code>country=nz</code> to match your own country code.</p>"},{"location":"users/placeholders/","title":"Placeholders","text":"<p>SolarNode supports placeholders in some setting values, such as datum data source IDs. These allow you to define a set of parameters that can be consistently applied to many settings.</p> <p>For example, imagine you manage many SolarNode devices across different buildings or sites. You'd like to follow a naming convention for your datum data source ID values that include a code for the building the node is deployed in, along the lines of <code>/BUILDING/DEVICE</code>. You could define a placeholder <code>building</code> and then configure the source IDs like <code>/{building}/device</code>. On each node you'd define the <code>building</code> placeholder with a building-specific value, so at runtime the nodes would resolve actual source ID values with those names replacing the <code>{building}</code> placeholder, for example <code>/OFFICE1/meter</code>.</p>"},{"location":"users/placeholders/#placeholder-syntax","title":"Placeholder syntax","text":"<p>Placeholders are written using the form <code>{name:default}</code> where <code>name</code> is the placeholder name and <code>default</code> is an optional default value to apply if no placeholder value exists for the given name. If a default value is not needed, omit the <code>colon</code> so the placeholder becomes just <code>{name}</code>.</p> <p>For example, imagine a set of placeholder values like</p> Name Value building OFFICE1 room BREAK <p>Here are some example settings with placeholders with what they would resolve to:</p> Input Resolved value <code>/{building}/meter</code> <code>/OFFICE1/meter</code> <code>/{building}/{room}/temp</code> <code>/OFFICE1/BREAK/temp</code> <code>/{building}/{floor:1}/{room}</code> <code>/OFFICE1/1/BREAK</code>"},{"location":"users/placeholders/#static-placeholder-configuration","title":"Static placeholder configuration","text":"<p>SolarNode will look for placeholder values defined in properties files stored in the <code>conf/placeholders.d</code> directory by default. In SolarNodeOS this is the <code>/etc/solarnode/placeholders.d</code> directory.</p> <p>Warning</p> <p>These files are only loaded once, when SolarNode starts up. If you make changes to any of them then SolarNode must be restarted.</p> <p>The properties file names must have a <code>.properties</code> extension and follow Java properties file syntax. Put simply, each file contains lines like</p> <pre><code>name = value\n</code></pre> <p>where <code>name</code> is the placeholder name and <code>value</code> is its associated value. The example set of placeholder values shown previously could be defined in a <code>/etc/solarnode/placeholders.d/mynode.properties</code> file with this content:</p> <pre><code>building = OFFICE1\nroom = BREAK\n</code></pre>"},{"location":"users/placeholders/#dynamic-placeholder-configuration","title":"Dynamic placeholder configuration","text":"<p>SolarNode also supports storing placeholder values as Settings using the key <code>placeholder</code>. The SolarUser /instruction/add API can be used with the UpdateSetting topic to modify the placeholder values as needed. The <code>type</code> value is the placeholder name and the <code>value</code> the placeholder value. Placeholders defined this way have priority over any similarly-named placeholders defined statically. Changes take effect as soon as SolarNode receives and processes the instruction.</p> <p>Warning</p> <p>Once a placeholder value is set via the <code>UpdateSetting</code> instruction, the same value defined as a static placeholder will be overridden and changes to the static value will be ignored.</p> <p>For example, to set the <code>floor</code> placeholder to <code>2</code> on node 123, you could make a <code>POST</code> request to <code>/solaruser/api/v1/sec/instr/add/UpdateSetting</code> with the following JSON body:</p> <pre><code>{\n\"nodeId\": 123,\n\"params\":{\n\"key\":   \"placeholder\",\n\"type\":  \"floor\",\n\"value\": \"2\"\n}\n}\n</code></pre> <p>Multiple settings can be updated as well, using a different syntax. Here's a request that sets both <code>floor</code> to <code>2</code> and <code>room</code> to <code>MEET</code>:</p> <pre><code>{\"nodeId\":123,\"parameters\":[\n{\"name\":\"key\",   \"value\":\"placeholder\"},\n{\"name\":\"type\",  \"value\":\"floor\"},\n{\"name\":\"value\", \"value\":\"2\"},\n{\"name\":\"key\",   \"value\":\"placeholder\"},\n{\"name\":\"type\",  \"value\":\"room\"},\n{\"name\":\"value\", \"value\":\"MEET\"}\n]}\n</code></pre>"},{"location":"users/remote-access/","title":"Remote Access","text":"<p>SolarSSH is SolarNetwork's method of connecting to SolarNode devices over the internet even when those devices are not directly reachable due to network firewalls or routing rules. It uses the Secure Shell Protocol (SSH) to ensure your connection is private and secure.</p> <p>SolarSSH does not maintain permanently open SSH connections to SolarNode devices. Instead the connections are established on demand, when you need them. This allows you to connect to a SolarNode when you need to perform maintenance, but not require SolarNode maintain an open SSH connection to SolarSSH.</p> <p>In order to use SolarSSH, you will need a User Security Token to use for authentication.</p>"},{"location":"users/remote-access/#browser-connection","title":"Browser Connection","text":"<p>You can use SolarSSH right in your browser to connect to any of your nodes.</p> <p> </p> <p>The SolarSSH browser app</p>"},{"location":"users/remote-access/#choose-your-node-id","title":"Choose your node ID","text":"<p>Click on the node ID in the page title to change what node you want to connect to.</p> <p> </p> <p>Changing the SolarSSH node ID</p> <p>Bookmark a SolarSSH page for your node ID</p> <p>You can append a <code>?nodeId=X</code> to the SolarSSH browser URL https://go.solarnetwork.net/solarssh/, where <code>X</code> is a node ID, to make the app start with that node ID directly. For example to start with node 123, you could bookmark the URL https://go.solarnetwork.net/solarssh/?nodeId=123.</p>"},{"location":"users/remote-access/#provide-your-credentials","title":"Provide your credentials","text":"<p>Fill in User Security Token credentials for authentication. The node ID you are connecting to must be owned by the same account as the security token.</p>"},{"location":"users/remote-access/#connect","title":"Connect","text":"<p>Click the Connect button to initiate the SolarSSH connection process. You will be presented with a dialog form to provide your SolarNodeOS system account credentials. This is only necessary if you want to connect to the SolarNodeOS system command line. If you only need to access the SolarNode Setup App, you can click the Skip button to skip this step. Otherwise, click the Login button to log into the system command line.</p> <p> </p> <p>SolarNodeOS system account credentials form</p> <p>SolarSSH will then establish the connection to your node. If you provided SolarNodeOS system account credentials previously and clicked the Login button, you will end up with a system command prompt, like this:</p> <p> </p> <p>SolarSSH logged-in system command prompt</p>"},{"location":"users/remote-access/#remote-setup-app","title":"Remote Setup App","text":"<p>Once connected, you can access the remote node's Setup App by clicking the Setup button in the top-right corner of the window. This will open a new browser tab for the Setup App.</p> <p> </p> <p>Accessing the SolarNode Setup App through a SolarSSH web connection</p>"},{"location":"users/remote-access/#direct-connection","title":"Direct connection","text":"<p>SolarSSH also supports a \"direct\" connection mode, that allows you to connect using standard ssh client applications. This is a more advanced (and flexible) way of connecting to your nodes, and even allows you to access other network services on the same network as the node and provides full SSH integration including port forwarding, <code>scp</code>, and <code>sftp</code> support.</p> <p>Direct SolarSSH connections require using a SSH client that supports the SSH \"jump\" host feature. The \"jump\" server hosted by SolarNetwork Foundation is available at <code>ssh.solarnetwork.net:9022</code>.</p> <p>The \"jump\" connection user is formed by combining a node ID with a user security token, separated by a <code>:</code> character. The general form of a SolarSSH direct connection \"jump\" host thus looks like this:</p> <pre><code>NODE:TOKEN@ssh.solarnetwork.net:9022\n</code></pre> <p>where <code>NODE</code> is a SolarNode ID and <code>TOKEN</code> is a SolarNetwork user security token.</p> <p>The actual SolarNode user can be any OS user (typically <code>solar</code>) and the hostname can be anything. A good practice for the hostname is to use one derived from the SolarNode ID, e.g. <code>solarnode-123</code>.</p> <p>Using OpenSSH a complete connection command to log in as a <code>solar</code> user looks like this, passing the \"jump\" host via a <code>-J</code> argument:</p> <pre><code>ssh -J 'NODE:TOKEN@ssh.solarnetwork.net:9022' solar@solarnode-NODE\n</code></pre> <p>Warning</p> <p>SolarNetwork security tokens often contain characters that must be escaped with a <code>\\</code> character for your shell to interpret them correctly. For example, a token like <code>9gPa9S;Ux1X3kK)YN6&amp;g</code> might need to have the <code>;)&amp;</code> characters escaped like <code>9gPa9S\\;Ux1X3kK\\)YN6\\&amp;g</code>.</p> <p>You will be first prompted to enter a password, which must be the token secret. You might then be prompted for the SolarNode OS user's password. Here's an example screen shot:</p> <p> </p> <p>Accessing the SolarNode system command line through a SolarSSH direct connection</p>"},{"location":"users/remote-access/#shell-shortcut-function","title":"Shell shortcut function","text":"<p>If you find yourself using SolarSSH connections frequently, a handy <code>bash</code> or <code>zsh</code> shell function can help make the connection process easier to remember. Here's an example that give you a <code>solarssh</code> command that accepts a SolarNode ID argument, followed by any optional SSH arguments:</p> <pre><code>function solarssh () {\nlocal node_id=\"$1\"\nif [ -z \"$node_id\" ]; then\necho 'Must provide node ID , e.g. 123'\nelse\nshift\necho \"Enter SN token secret when first prompted for password. Enter node $node_id password second.\"\nssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR \\\n-J \"$node_id\"'SN_TOKEN_HERE@ssh.solarnetwork.net:9022' $@ solar@solarnode-$node_id\nfi\n}\n</code></pre> <p>Just replace <code>SN_TOKEN_HERE</code> with a user security token. After integrating this into your shell's configuration (e.g. <code>~/.bashrc</code> or <code>~/.zshrc</code>) then you could connect to node <code>123</code> like:</p> <pre><code>solarssh 123\n</code></pre>"},{"location":"users/security-tokens/","title":"Security Tokens","text":"<p>Some SolarNode features require SolarNetwork Security Tokens to use as authentication credentails for SolarNetwork services. Security Tokens are managed on the Security Tokens page in SolarNetwork.</p> <p> </p> <p>The Security Tokens page in SolarNetwork</p>"},{"location":"users/security-tokens/#user-tokens","title":"User Tokens","text":"<p>User Security Tokens allow access to web services that perform functions directly on your behalf, for example issue an instruction to your SolarNode.</p> <p>Click the \"+\" button in the User Tokens section to generate a new security token. You will be shown a form where you can give a name, description, and policy restrictions for the token.</p> <p> </p> <p>The form for creating a new User Security Token</p> <p>Click the Generate Security Token button to generate the new token. You will then be shown the generated token. You will need to copy and save the token to a safe and secure place.</p> <p> </p> <p>A newly generated security token \u2014 make sure to save the token in a safe place</p>"},{"location":"users/security-tokens/#data-tokens","title":"Data Tokens","text":"<p>Data Security Tokens allow access to web services that query the data collected by your SolarNodes.</p> <p>Click the \"+\" button in the Data Tokens section to generate a new security token. You will be shown a form where you can give a name, description, and policy restrictions for the token.</p> <p> </p> <p>The form for creating a new Data Security Token</p> <p>Click the Generate Security Token button to generate the new token. You will then be shown the generated token. You will need to copy and save the token to a safe and secure place.</p>"},{"location":"users/security-tokens/#security-policy","title":"Security Policy","text":"<p>Security tokens can be configured with a Security Policy that restricts the types of functions or data the token has permission to access.</p> Policy User Node Description API Paths Restrict the token to specific API methods. Expiry Make the token invalid after a specific date. Minimum Aggregation Restrict the data aggregation level allowed. Node IDs Restrict to specific node IDs. Refresh Allowed Make the token invalid after a specific date. Source IDs Restrict to specific datum source IDs. Node Metadata Restrict to specific node metadata. User Metadata Restrict to specific user metadata."},{"location":"users/security-tokens/#api-paths","title":"API Paths","text":"<p>The API Paths policy restricts the token to specific SolarNet API methods, based on their URL path. If this policy is not included then all API methods are allowed.</p>"},{"location":"users/security-tokens/#expiry","title":"Expiry","text":"<p>The Expiry policy makes the token invalid after a specific date. If this policy is not included, the token does not ever expire.</p>"},{"location":"users/security-tokens/#minimum-aggregation","title":"Minimum Aggregation","text":"<p>The Minimum Aggregation policy restricts the token to a minimum data aggregation level. If this policy is not included, or of the minimum level is set to None, data for any aggregation level is allowed.</p>"},{"location":"users/security-tokens/#node-ids","title":"Node IDs","text":"<p>The Node IDspolicy restrict the token to specific node IDs. If this policy is not included, then the token has access to all node IDs in your SolarNetwork account.</p>"},{"location":"users/security-tokens/#node-metadata","title":"Node Metadata","text":"<p>The Node Metadata policy restricts the token to specific portions of node-level metadata. If this policy is not included then all node metadata is allowed.</p>"},{"location":"users/security-tokens/#refresh-allowed","title":"Refresh Allowed","text":"<p>The Refresh Allowed policy grants applications given a signing key rather than the token's private password can refresh the key as long as the token has not expired.</p>"},{"location":"users/security-tokens/#source-ids","title":"Source IDs","text":"<p>The Source IDs policy restrict the token to specific datum source IDs. If this policy is not included, then the token has access to all source IDs in your SolarNetwork account.</p>"},{"location":"users/security-tokens/#user-metadata","title":"User Metadata","text":"<p>The User Metadata policy restricts the token to specific portions of account-level metadata. If this policy is not included then all user metadata is allowed.</p>"},{"location":"users/settings/","title":"Settings Files","text":"<p>SolarNode plugins support configurable properties, called settings. The SolarNode setup app allows you to manage settings through simple web forms.</p> <p>Settings can also be exported and imported in a CSV format, and can be applied when SolarNode starts up with Auto Settings CSV files. Here is an example of a settings form in the SolarNode setup app:</p> <p></p> <p>There are 3 settings represented in that screen shot:</p> <ol> <li>Schedule</li> <li>Destination</li> <li>Temporary Destination</li> </ol> <p>Tip</p> <p>Nearly every form field you can edit in the SolarNode setup app represents a setting for a component in SolarNode.</p> <p>In the SolarNode setup app the settings can be imported and exported from the main Settings screen in the Settings Backup &amp; Restore section:</p> <p></p>"},{"location":"users/settings/#settings-csv-example","title":"Settings CSV example","text":"<p>Here's an example snippet of a settings CSV file:</p> <pre><code>net.solarnetwork.node.io.modbus.1,serialParams.baudRate,19200,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.1,serialParams.parityString,even,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.1,serialParams.portName,/dev/cuaU0,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.FACTORY,1,1,0,2014-03-01 21:00:31\n</code></pre> <p>These settings all belong to a <code>net.solarnetwork.node.io.modbus</code> component. The meaning of the CSV columns is discussed in the following section.</p>"},{"location":"users/settings/#settings-csv-syntax","title":"Settings CSV syntax","text":"<p>Settings files are CSV (comma separated values) files, easily exported from spreadsheet applications like Microsoft Excel or Google Sheets. The CSV must include a header row, which is skipped. All other rows will be processed as settings.</p> <p>The Settings CSV format uses a quite general format and contains the following columns:</p> # Name Description 1 key A unique identifier for the service the setting applies to. 2 type A unique identifier for the setting with the service specified by <code>key</code>, typically using standard property syntax. 3 value The setting value. 4 flags An integer bitmask of flags associated with the setting. See the flags section for more info. 5 modified The date the setting was last modified, in <code>yyyy-MM-dd HH:mm:ss</code> format. <p>To understand the <code>key</code> and <code>type</code> values required for a given component requires consulting the documentation of the plugin that provides that component. You can get a pretty good picture of what the values are by exporting the settings after configuring a component in SolarNode. Typically the <code>key</code> value will mirror a plugin's Java package name, and <code>type</code> follows a JavaScript-like property accessor syntax representing a configurable property on the component.</p>"},{"location":"users/settings/#setting-property-syntax","title":"Setting property syntax","text":"<p>The <code>type</code> setting value usually defines a component property using a JavaScript-like syntax with these rules:</p> Expression Example Description Property <code>name</code> a property named <code>name</code> Nested property <code>name.subname</code> a nested property <code>subname</code> on a parent property <code>name</code> List property <code>name[0]</code> the first element of an indexed list property named <code>name</code> Map property <code>name['key']</code> the <code>key</code> element of the map property <code>name</code> <p>These rules can be combined into complex expressions, for example <code>propIncludes[0].name</code> or <code>delegate.connectionFactory.propertyFilters['UID']</code>.</p>"},{"location":"users/settings/#setting-flags","title":"Setting flags","text":"<p>Each setting has a set of flags that can be associated with it. The following table outlines the bit offset for each flag along with a description:</p> # Name Description 0 Ignore modification date If this flag is set then changes to the associated setting will not trigger a new auto backup. 1 Volatile If this flag is set then changes to the associated setting will not trigger an internal \"setting changed\" event to be broadcast. <p>Note these are bit offsets, so the decimal value to ignore modification date is <code>1</code>, to mark as volatile is <code>2</code>, and for both is <code>3</code>.</p>"},{"location":"users/settings/#component-factories","title":"Component factories","text":"<p>Many plugins provide component factories which allow you to configure any number of instances of that component. Each component instance is assigned a unique identifier when it is created. In the SolarNode setup app, the component instance identifiers appear throughout the UI:</p> <p></p> <p>In the previous example CSV the Modbus I/O plugin allows you to configure any number of Modbus connection components, each with their own specific settings. That is an example of a component factory. The settings CSV will include a special row to indicate that such a factory component should be activated, using a unique identifier, and then all the settings associated with that factory instance will have that unique identifier appended to its <code>key</code> values.</p> <p>Going back to that example CSV, this is the row that activates a Modbus I/O component instance with an identifier of <code>1</code>:</p> <pre><code>net.solarnetwork.node.io.modbus.FACTORY,1,1,0,2014-03-01 21:00:31\n</code></pre> <p>The synax for <code>key</code> column is simply the service identifier followed by <code>.FACTORY</code>. Then the <code>type</code> and <code>value</code> columns are both set the same unique identifier. In this example that identifier is <code>1</code>. For all settings specific to a factory component, the <code>key</code> column will be the service identifier followed by <code>.IDENTIFIER</code> where <code>IDENTIFIER</code> is the unique instance identifier.</p> <p>Here is an example that shows two factory instances configured: <code>Lighting</code> and <code>HVAC</code>. Each have a different <code>serialParams.portName</code> setting value configured:</p> <pre><code>net.solarnetwork.node.io.modbus.Lighting,serialParams.portName,/dev/cuaU0,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.HVAC,serialParams.portName,/dev/ttyUSB0,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.FACTORY,Lighting,Lighting,0,2014-03-01 21:00:31\nnet.solarnetwork.node.io.modbus.FACTORY,HVAC,HVAC,0,2014-03-01 21:00:31\n</code></pre>"},{"location":"users/settings/#auto-settings","title":"Auto settings","text":"<p>SolarNode settings can also be configured through Auto Settings, applied when SolarNode starts up, by placing Settings CSV files in the <code>/etc/solarnode/auto-settings.d</code> directory. These settings are applied only if they don't already exist or the modified date in the settings file is newer than the date they were previously applied.</p>"},{"location":"users/setup-app/","title":"Setup App","text":"<p>The SolarNode Setup App allows you to manage SolarNode through a web browser.</p> <p>To access the Setup App, you need to know the network address of your SolarNode. In many cases you can try accessing http://solarnode/. If that does not work, you need to find the network address SolarNode is using.</p> <p>Here is an example screen shot of the SolarNode Setup App:</p> <p></p>"},{"location":"users/setup-app/certificates/","title":"Certificates","text":"<p>TODO</p> <p></p>"},{"location":"users/setup-app/home/","title":"Home","text":"<p>TODO</p> <p></p>"},{"location":"users/setup-app/login/","title":"Login","text":"<p>You must log in to SolarNode to access its functions. The login credentials will have been created when you first set up SolarNode and associated it with your SolarNetwork account. The default Username will be your SolarNetwork account email address, and the password will have been randomly generated and shown to you.</p> <p>Tip</p> <p>You can change your SolarNode username and password after logging in. Note these credentials are not related, or tied to, your SolarNetwork login credentials.</p> <p></p>"},{"location":"users/setup-app/plugins/","title":"Plugins","text":"<p>TODO</p>"},{"location":"users/setup-app/profile/","title":"Profile","text":"<p>The profile menu in the top-right of the Setup App menu give you access to change  you password, change  you username, logout, restart, and reset SolarNode.</p> <p>Tip</p> <p>Your SolarNode credentials are not related, or tied to, your SolarNetwork login credentials. Changing your SolarNode username or password does not change your SolarNetwork credentials.</p> <p> </p> <p>The profile menu in SolarNode</p>"},{"location":"users/setup-app/profile/#change-password","title":"Change Password","text":"<p>Choosing the Change Password menu item will take you to a form for changing your password. Fill in your current password and then your new password, then click the Submit Password button.</p> <p> </p> <p>The Change Password form</p> <p>As a result, you will stay on the same page, but a success (or error) message will be shown above the form:</p> <p></p>"},{"location":"users/setup-app/profile/#change-username","title":"Change Username","text":"<p>Choosing the Change Username menu item will take you to a form for changing your SolarNode username. Fill in your current password and then your new password, then click the Change Username button.</p> <p> </p> <p>The Change Username form</p> <p>As a result, you will stay on the same page, but a success (or error) message will be shown above the form:</p> <p></p>"},{"location":"users/setup-app/profile/#logout","title":"Logout","text":"<p>Choosing the Logout menu item will immediately end your SolarNode session and log you out. You will ned to log in again to use the Setup App further.</p>"},{"location":"users/setup-app/profile/#restart","title":"Restart","text":"<p>You can either restart or reboot SolarNode from the Restart SolarNode menu. A restart means the SolarNode app will restart, while a reboot means the entire SolarNodeOS device will shut down and boot up again (restarting SolarNode along the way).</p> <p>You might need to restart SolarNode to pick up new plugins you've installed, and you might need to reboot SolarNode if you've attached new sensors or other devices that require operating system support.</p> <p> </p> <p>The Restart SolarNode menu brings up this dialog.</p>"},{"location":"users/setup-app/profile/#reset","title":"Reset","text":"<p>You can perform a \"factory reset\" of SolarNode to remove all your custom settings, certificate, login credentials, and so on. You also have the option to preserve some SolarNodeOS settings like WiFi credentials if you like.</p> <p> </p> <p>The Reset SolarNode menu brings up this dialog.</p>"},{"location":"users/setup-app/settings/","title":"Settings","text":"<p>The Settings page in SolarNode Setup is where you can configure all available SolarNode settings. The page is divided 4 main sections, outlined next.</p>"},{"location":"users/setup-app/settings/#components","title":"Components","text":"<p>The Components section lists all the configurable multi-instance components available on your SolarNode. Multi-instance means you can configure any number of a given component, each with their own settings.</p> <p>For example imagine you want to collect data from a power meter, solar inverter, and weather station, all of which use the Modbus protocol. To do that you would configure three instances of the Modbus Device component, one for each device.</p> <p>Use the Manage button for any listed compoennt to add or remove instances of that component.</p> <p>An instance count badge appears next to any component with at least one instance configured.</p> <p></p>"},{"location":"users/setup-app/settings/#settings_1","title":"Settings","text":"<p>Other configurable services that are not Components appear in the Settings section.</p> <p>Each setting will include a  button that will show you a brief description of that setting.</p> <p></p> <p>After making any change, an Active value label will appear, showing the currently active value for that setting.</p> <p></p> <p>In order to save your changes, you must click the Save All Changes button. You may need to scroll the page to find it!</p> <p></p>"},{"location":"users/setup-app/settings/#backup-restore","title":"Backup &amp; Restore","text":"<p>The Backup &amp; Restore section lets you manage SolarNode backups. Each backup contains a snapshot of the settings you have configured, the node's certificate, and custom plugins.</p> <p></p>"},{"location":"users/setup-app/settings/#file-system-backup-service","title":"File System Backup Service","text":"<p>The File System Backup Service is the default Backup Service provided by SolarNode. It saves the backup onto the node itself. In order to be able to restore your settings if the node is damaged or lost, you must download a copy of a backup using the Download button, and save the file to a safe place.</p> <p>Warning</p> <p>If you do not download a copy of a backup, you run the risk of losing your settings and node certificate, making it impossible to restore the node in the event of a catastrophic hardware failure.</p> <p>The configurable settings of the File System Backup Service are:</p> Setting Description Backup Directory The folder (on the node) where the backups will be saved. Copies The number of backup copies to keep, before deleting the oldest backup."},{"location":"users/setup-app/settings/#s3-backup-service","title":"S3 Backup Service","text":"<p>The S3 Backup Service creates cloud-based backups in AWS S3 (or any compatible provider). You must configure the credentials and S3 location details to use before any backups can be created.</p> <p></p> <p>Note</p> <p>The S3 Backup Service requires the S3 Backup Service Plugin.</p> <p>The configurable settings of the S3 Backup Service are:</p> Setting Description AWS Token The AWS access token to authenticate with. AWS Secret The AWS access token secret to authenticate with. AWS Region The name of the Amazon region to use, for example <code>us-west-2</code>. S3 Bucket The name of the S3 bucket to use. S3 Path An optional root path to use for all backup data (typically a folder location). Storage Class A supported storage class, such as STANDARD (the default), <code>STANDARD_IA</code>, <code>INTELLIGENT_TIERING</code>, <code>REDUCED_REDUNDANCY</code>, and so on. Copies The number of backup copies to keep, before deleting the oldest backup. Cache Seconds The amount of time to cache backup metadata such as the list of available backups, in seconds."},{"location":"users/setup-app/settings/#settings-backup-restore","title":"Settings Backup &amp; Restore","text":"<p>The Settings Backup &amp; Restore section provides a way to manage Settings Files and Settings Resources, both of which are backups for the configured settings in SolarNode.</p> <p>Warning</p> <p>Settings Files and Settings Resources do not include the node's certificate or custom plugins. See the Backup &amp; Restore section for managing \"full\" backups that do include those items.</p> <p></p> <p>The Export button allows you to download a Settings File with the currently active configuration.</p> <p>The Import button allows you to upload a previously-downloaded Settings File.</p> <p>The Settings Resource menu and associated Export to file button allow you to download specialized settings files, offered by some components in SolarNode.</p> <p>The Auto backups area will have a list of buttons, each of which will let you download a Settings File that SolarNode automatically created. Each button shows you the date the settings backup was created.</p>"},{"location":"users/setup-app/settings/components/","title":"Components","text":"<p>TODO</p> <p></p> <p></p>"},{"location":"users/setup-app/settings/datum-filters/","title":"Datum Filters","text":"<p>TODO</p> <p></p>"},{"location":"users/setup-app/settings/logging/","title":"Logging","text":"<p>The SolarNode UI supports configuring logger levels dynamically, without having to change the logging configuration file.</p> <p>Warning</p> <p>When SolarNode restarts all changes made in the Logger UI will be lost and the logger configuration will revert to whatever is configured in the logging configuration file.</p> <p></p> <p>The Logging page lists all the configured logger levels and lets you add new loggers and edit the existing ones using a simple form.</p> <p></p>"},{"location":"users/setup-app/settings/op-modes/","title":"Operational Modes","text":"<p>TODO</p>"},{"location":"users/setup-app/tools/","title":"Tools","text":"<p>TODO</p>"},{"location":"users/setup-app/tools/command-console/","title":"Command Console","text":""},{"location":"users/setup-app/tools/controls/","title":"Controls","text":"<p>TODO</p>"},{"location":"users/sysadmin/","title":"System Administration","text":"<p>SolarNode runs on SolarNodeOS, a Debian Linux-based operating system. If you are already familiar with Debian Linux, or one of the other Linux distributions built from Debian like Ubuntu Linux, you will find it pretty easy to get around in SolarNodeOS.</p>"},{"location":"users/sysadmin/#system-user-account","title":"System User Account","text":"<p>SolarNodeOS ships with a <code>solar</code> user account that you can use to log into the operating system. The default password is <code>solar</code> but may have been changed by a system administrator.</p> <p>Warning</p> <p>The <code>solar</code> user account is not related to the account you log into the SolarNode Setup App with.</p>"},{"location":"users/sysadmin/#change-system-user-account-password","title":"Change system user account password","text":"<p>To change the system user account's password, use the <code>passwd</code> command.</p> Changing the system user account password<pre><code>$ passwd\nChanging password for solar.\nCurrent password:\nNew password:\nRetype new password:\npasswd: password updated successfully\n</code></pre> <p>Tip</p> <p>Changing the <code>solar</code> user's password is highly recommended when you first deploy a node.</p>"},{"location":"users/sysadmin/#administrator-access","title":"Administrator Access","text":"<p>Some commands require administrative permission. The <code>solar</code> user can execute arbitrary commands with administrative permission by prefixing the command with <code>sudo</code>. For example the <code>reboot</code> command will reboot SolarNodeOS, but requires administrative permission.</p> Run a command as a system administrator<pre><code>$ sudo reboot\n</code></pre> <p>The <code>sudo</code> command will prompt you for the <code>solar</code> user's password and then execute the given command as the administrator user <code>root</code>.</p> <p>The <code>solar</code> user can also become the <code>root</code> administrator user by way of the <code>su</code> command:</p> Gain system administrative privledges with su<pre><code>$ sudo su -\n</code></pre> <p>Once you have become the <code>root</code> user you no longer need to use the <code>sudo</code> command, as you already have administrative permissions.</p>"},{"location":"users/sysadmin/#network-access-with-ssh","title":"Network Access with SSH","text":"<p>SolarNodeOS comes with an SSH service active, which allows you to remotely connect and access the command line, using any SSH client.</p>"},{"location":"users/sysadmin/date-time/","title":"Date and Time","text":"<p>SolarNodeOS includes date and time management functions through the timedatectl command. Run <code>timedatectl status</code> to view information about the current date and time settings.</p> Viewing the current date and time settings<pre><code>$ timedatectl status\n               Local time: Fri 2023-05-26 03:41:42 BST\n           Universal time: Fri 2023-05-26 02:41:42 UTC\n                 RTC time: n/a\n                Time zone: Europe/London (BST, +0100)\nSystem clock synchronized: yes\n              NTP service: active\n          RTC in local TZ: no\n</code></pre>"},{"location":"users/sysadmin/date-time/#changing-the-local-time-zone","title":"Changing the local time zone","text":"<p>SolarNodeOS uses the <code>UTC</code> time zone by default. If you would like to change this, use the <code>timedatectl set-timezone</code></p> Changing the local time zone<pre><code>$ sudo sudo timedatectl set-timezone Pacific/Auckland\n</code></pre> <p>You can list the available time zone names by running <code>timedatectl list-timezones</code>.</p>"},{"location":"users/sysadmin/date-time/#internet-time-synchronization","title":"Internet time synchronization","text":"<p>SolarNodeOS uses the systemd-timesyncd service to synchronize the node's clock with internet time servers. Normally no configuration is necessary. You can check the status of the network time synchronization with timedatectl like:</p> <pre><code>$ timedatectl status\n               Local time: Fri 2023-05-26 03:41:42 BST\n           Universal time: Fri 2023-05-26 02:41:42 UTC\n                 RTC time: n/a\n                Time zone: Europe/London (BST, +0100)\nSystem clock synchronized: yes\n              NTP service: active\n          RTC in local TZ: no\n</code></pre> <p>Warning</p> <p>For internet time synchronization to work, SolarNode needs to access Network Time Protocol (NTP) servers, using UDP over port 123.</p>"},{"location":"users/sysadmin/date-time/#network-time-server-configuration","title":"Network time server configuration","text":"<p>The NTP servers that SolarNodeOS uses are configured in the /etc/systemd/timesyncd.conf file. The default configuration uses a pool of Debian servers, which should be suitable for most nodes. If you would like to change the configuration, edit the <code>timesyncd.conf</code> file and change the <code>NTP=</code> line, for example</p> Configuring the NTP servers to use<pre><code>[Time]\nNTP=my.ntp.example.com\n</code></pre>"},{"location":"users/sysadmin/date-time/#setting-the-date-and-time","title":"Setting the date and time","text":"<p>In order to manually set the date and time, NTP time synchronization must be disabled with <code>timedatectl set-ntp false</code>. Then you can run <code>timedatectl set-time</code> to set the date:</p> Manually changing the date and time<pre><code>$ sudo timedatectl set-ntp false\n$ sudo timedatectl set-time \"2023-05-26 17:30:00\"\n</code></pre> <p>If you then look at the <code>timedatectl status</code> you will see that NTP has been disabled:</p> Status with NTP disabled<pre><code>$ timedatectl\n               Local time: Fri 2023-05-26 17:30:30 NZST\n           Universal time: Fri 2023-05-26 05:30:30 UTC\n                 RTC time: n/a\n                Time zone: Pacific/Auckland (NZST, +1200)\nSystem clock synchronized: no # (1)!\nNTP service: inactive # (2)!\nRTC in local TZ: no\n</code></pre> <ol> <li>The clock is not synchronized with internet time servers, as it shows no</li> <li>The NTP service has been disabled, as it is listed as inactive</li> </ol> <p>You can re-enable NTP time synchronization like this:</p> Enabling NTP time synchronization<pre><code>$ sudo timedatectl set-ntp true\n</code></pre>"},{"location":"users/sysadmin/networking/","title":"Networking","text":"<p>SolarNodeOS uses the systemd-networkd service to manage network devices and their settings. A network device relates to a physical network hardware device or a software networking component, as recognized and named by the operating system. For example, the first available ethernet device is typically named <code>eth0</code> and the first available WiFi device <code>wlan0</code>.</p>"},{"location":"users/sysadmin/networking/#network-configuration","title":"Network configuration","text":"<p>Network configuration is stored in <code>.network</code> files in the <code>/etc/systemd/network</code> directory. SolarNodeOS comes with default support for ethernet and WiFi network devices.</p> <p>The default <code>10-eth.network</code> file configures the default ethernet network <code>eth0</code> to use DHCP to automatically obtain a network address, routing information, and DNS servers to use.</p>"},{"location":"users/sysadmin/networking/#dhcp-configuration","title":"DHCP configuration","text":"<p>SolarNodeOS networks are configured to use DHCP by default. If you need to re-configure a network to use DHCP, change the configuration to look like this:</p> Ethernet network with DHCP configuration<pre><code>[Match]\nName=eth0\n\n[Network]\nDHCP=yes\n</code></pre> <p>Use a Name value specific to your network.</p>"},{"location":"users/sysadmin/networking/#static-network-configuration","title":"Static network configuration","text":"<p>If you need to use a static network address, instead of DHCP, edit the network configuration file (for example, the <code>10-eth.network</code> file for the ethernet network), and change it to look like this:</p> Ethernet network with static address configuration<pre><code>[Match]\nName=eth0\n\n[Network]\nDNS=1.1.1.1\n\n[Address]\nAddress=192.168.3.10/24\n\n[Route]\nGateway=192.168.3.1\n</code></pre> <p>Use Name, DNS, Address, and Gateway values specific to your network.</p>"},{"location":"users/sysadmin/networking/#wifi-network-configuration","title":"WiFi network configuration","text":"<p>The default <code>20-wlan.network</code> file configures the default WiFi network <code>wlan0</code> to use DHCP to automatically obtain a network address, routing information, and DNS servers to use. To configure the WiFi network SolarNode should connect to, run this command:</p> Configuring the SolarNode WiFi network<pre><code>sudo dpkg-reconfigure sn-wifi\n</code></pre> <p>You will then be prompted to supply the following WiFi settings:</p> <ol> <li>Country code, e.g. <code>NZ</code></li> <li>WiFi network name (SSID)</li> <li>WiFi network password</li> </ol> <p>Note about WiFi support</p> <p>WiFi support is provided by the <code>sn-wifi</code> package, which may not be installed. See the Package Maintenance section for information about installing packages.</p>"},{"location":"users/sysadmin/networking/#wifi-auto-access-point-mode","title":"WiFi Auto Access Point mode","text":"<p>For initial setup of a the WiFi settings on a SolarNode it can be helpful for SolarNode to create its own WiFi network, as an access point. The <code>sn-wifi-autoap@wlan0</code> service can be used for this. When enabled, it will monitor the WiFi network status, and when the WiFi connection fails for any reason it will enable a <code>SolarNode</code> WiFi network using a gateway IP address of <code>192.168.16.1</code>. Thus when the SolarNode access point is enabled, you can connect to that network from your own device and reach the Setup App at <code>http://192.168.16.1/</code> or the command line via <code>ssh solar@192.168.16.1</code>.</p> <p>The default <code>21-wlan-ap.network</code> file configures the default WiFi network <code>wlan0</code> to act as an Access Point</p> <p>This service is not enabled by default. To enable it, run the following:</p> <pre><code>sudo systemctl enable --now sn-wifi-autoap@wlan0\n</code></pre> <p>Once enabled, if SolarNode cannot connect to the configured WiFi network, it will create its own <code>SolarNode</code> network. By default the password for this network is <code>solarnode</code>. The Access Point network configuration is defined in the <code>/etc/network/wpa_supplicant-wlan0.conf</code> file, in a section like this:</p> <pre><code>### access-point mode\nnetwork={\n    ssid=\"SolarNode\"\n    mode=2\n    key_mgmt=WPA-PSK\n    psk=\"solarnode\"\n    frequency=2462\n}\n</code></pre>"},{"location":"users/sysadmin/packages/","title":"Package Maintenance","text":"<p>SolarNodeOS supports a wide variety of software packages. You can install new packages as well as apply package updates as they become available. The apt command performs these tasks.</p>"},{"location":"users/sysadmin/packages/#update-package-metadata","title":"Update package metadata","text":"<p>For SolarNodeOS to know what packages, or package updates, are available, you need to periodically update the available package information. This is done with the <code>apt update</code> command:</p> Update package information<pre><code>sudo apt update # (1)!\n</code></pre> <ol> <li>The <code>sudo</code> command runs other commands with administrative privledges.    It will prompt you for your user account password (typically the <code>solar</code> user).</li> </ol>"},{"location":"users/sysadmin/packages/#list-installed-packages","title":"List installed packages","text":"<p>Use the <code>apt list</code> command to list the installed packages:</p> Listing the installed packages<pre><code>apt list --installed\n</code></pre>"},{"location":"users/sysadmin/packages/#update-packages","title":"Update packages","text":"<p>To see if there are any package updates available, run <code>apt list</code> like this:</p> List packages with updates available<pre><code>apt list --upgradable\n</code></pre> <p>If there are updates available, that will show them. You can apply all package updates with the <code>apt upgrade</code> command, like this:</p> Upgrade all packages<pre><code>sudo apt upgrade\n</code></pre> <p>If you want to install an update for a specific package, use the <code>apt install</code> command instead.</p> <p>Tip</p> <p>The <code>apt upgrade</code> command will update existing packages and install packages that are required by those packages, but it will never remove an existing package. Sometimes you will want to allow packages to be removed during the upgrade process; to do that use the <code>apt full-upgrade</code> command.</p>"},{"location":"users/sysadmin/packages/#search-for-packages","title":"Search for packages","text":"<p>Use the <code>apt search</code> command to search for packages. By default this will match package names and their descriptions. You can search just for package names by including a <code>--names-only</code> argument.</p> Search for packages<pre><code># search for \"name\" across package names and descriptions\napt search name\n\n# search for \"name\" across package names only\napt search --names-only name\n\n# multiple search terms are logically \"and\"-ed together\napt search name1 name2\n</code></pre>"},{"location":"users/sysadmin/packages/#install-packages","title":"Install packages","text":"<p>The <code>apt install</code> command will install an available package, or an individual package update.</p> Install package<pre><code>sudo apt install mypackage\n</code></pre>"},{"location":"users/sysadmin/packages/#remove-packages","title":"Remove packages","text":"<p>You can remove packages with the <code>apt remove</code> command. That command will preserve any system configuration associated with the package(s); if you would like to also remove that you can use the <code>apt purge</code> command.</p> Removing packages<pre><code>sudo apt remove mypackage\n\n# use `purge` to also remove configuration\nsudo apt purge mypackage\n</code></pre>"},{"location":"users/sysadmin/solarnode-service/","title":"SolarNode Service","text":"<p>SolarNode is managed as a systemd service. There are some shortcut commands to more easily manage the service.</p> Command Description <code>sn-start</code> Start the SolarNode service. <code>sn-restart</code> Restart the SolarNode service. <code>sn-status</code> View status information about the SolarNode service (see if it is running or not). <code>sn-stop</code> Stop the SolarNode service. <p>The <code>sn-stop</code> command requires administrative permissions, so you may be prompted for your system account password (usually the <code>solar</code> user's password).</p>"},{"location":"users/sysadmin/solarnode-service/#solarnode-service-environment","title":"SolarNode service environment","text":"<p>You can modify the environment variables passed to the SolarNode service, as well as modify the Java runtime options used. You may want to do this, for example, to turn on Java remote debugging support or to give the SolarNode process more memory.</p> <p>The systemd <code>solarnode.service</code> unit will load the <code>/etc/solarnode/env.conf</code> environment configuration file if it is present. You can define arbitrary environment variables using a simple <code>key=value</code> syntax.</p> <p>SolarNodeOS ships with a <code>/etc/solarnode/env.conf.example</code> file you can use for reference.</p>"},{"location":"users/sysadmin/solarssh/","title":"SolarSSH","text":"<p>The <code>sn-solarssh</code> package in SolarNodeOS provides a <code>solarssh</code> command-line tool for managing SolarSSH connections.</p>"},{"location":"users/sysadmin/solarssh/#show-ssh-public-key","title":"Show SSH public key","text":"<p>To view the node's public SSH key, you can execute <code>solarssh showkey</code>.</p> <pre><code>$ solarssh showkey\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIG7DWIuC2MVHy/gfD32sCayoVFpGVbZ8VXuQubmKjwyx SolarNode\n</code></pre>"},{"location":"users/sysadmin/solarssh/#list-solarssh-sessions","title":"List SolarSSH sessions","text":"<p>Run <code>solarssh list</code> to view all available SolarSSH sessions.</p> <pre><code>$ solarssh list\nb0ae36e0-06ae-4d3d-b34e-9bf2ca8049f1,ssh.solarnetwork.net,8022,43340\n</code></pre>"},{"location":"users/sysadmin/solarssh/#view-solarssh-session-status","title":"View SolarSSH session status","text":"<p>Using the output of <code>solarssh list</code> you can view the SSH connection status of a specific SSH session with <code>solarssh status</code>, like this:</p> <pre><code>$ solarssh -c b0ae36e0-06ae-4d3d-b34e-9bf2ca8049f1,ssh.solarnetwork.net,8022,43340 status\nactive\n</code></pre>"},{"location":"users/sysadmin/solarssh/#stop-solarssh-session","title":"Stop SolarSSH session","text":"<p>You can force a SolarSSH session to end using <code>solarssh stop</code>, like this:</p> <pre><code>$ solarssh -c b0ae36e0-06ae-4d3d-b34e-9bf2ca8049f1,ssh.solarnetwork.net,8022,43340 stop\n</code></pre>"}]}