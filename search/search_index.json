{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SolarNode Handbook","text":"<p>This handbook provides guides and reference documentation about SolarNode, the distributed component of SolarNetwork.</p>"},{"location":"#user-guide","title":"User Guide","text":"<p>For information on getting and using SolarNode, see the User Guide.</p>"},{"location":"#developer-guide","title":"Developer Guide","text":"<p>For information on working on the SolarNode codebase, such as writing a plugin, see the Developer Guide.</p>"},{"location":"developers/","title":"Developer Guide","text":"<p>This section of the handbook is geared towards developers working with the SolarNode codebase to develop a plugin.</p>"},{"location":"developers/#solarnode-source","title":"SolarNode source","text":"<p>The core SolarNode platform code is available on GitHub.</p>"},{"location":"developers/#getting-started","title":"Getting started","text":"<p>See the SolarNode Development Guide to set up your own development environment for writing SolarNode plugins.</p>"},{"location":"developers/osgi/","title":"Plugins","text":"<p>The SolarNode platform has been designed to be highly modular and dynamic, by using a plugin-based architecture. The plugin system SolarNode uses is based on the OSGi specification, where plugins are implemented as OSGi bundles. SolarNode can be thought of as a collection of OSGi bundles that, when combined and deployed together in an OSGi framework like Eclipse Equinox, form the complete SolarNode platform.</p> <p>To summarize: everything in SolarNode is a plugin!</p> <p>OSGi bundles and Eclipse plug-ins</p> <p>Each OSGi bundle in SolarNode comes configured as an Eclipse IDE (or simply Eclipse) plug-in project. Eclipse refers to OSGi bundles as \"plug-ins\" and its OSGi development tools are collectively known as the Plug-in Development Environment, or PDE for short. We use the terms bundle and plug-in and plugin somewhat interchangably in the SolarNode project. Although Eclipse is not actually required for SolarNode development, it is very convenient.</p> <p>Practically speaking a plugin, which is an OSGi bundle, is simply a Java JAR file that includes the Java code implementing your plugin and some OSGi metadata in its Manifest. For example, here is the contents of the <code>net.solarnetwork.common.jdt</code> plugin JAR:</p> <pre><code>META-INF/MANIFEST.MF\nnet/solarnetwork/common/jdt/Activator.class\nnet/solarnetwork/common/jdt/ClassLoaderNameEnvironment.class\nnet/solarnetwork/common/jdt/CollectingCompilerRequestor.class\nnet/solarnetwork/common/jdt/CompilerUtils.class\nnet/solarnetwork/common/jdt/JdtJavaCompiler.class\nnet/solarnetwork/common/jdt/MapClassLoader.class\nnet/solarnetwork/common/jdt/ResourceCompilationUnit.class\n</code></pre>"},{"location":"developers/osgi/#services","title":"Services","text":"<p>Central to the plugin architecture SolarNode uses is the concept of a service. In SolarNode a service is defined by a Java interface. A plugin can advertise a service to the SolarNode runtime. Plugins can lookup a service in the SolarNode runtime and then invoke the methods defined on it.</p> <p>The advertising/lookup framework SolarNode uses is provided by OSGi. OSGi provides several ways to manage services. In SolarNode the most common is to use Blueprint XML documents to both publish services (advertise) and acquire references to services (lookup).</p>"},{"location":"developers/osgi/blueprint/","title":"Blueprint","text":"<p>SolarNode supports the OSGi Blueprint Container Specification so plugins can declare their service dependencies and register their services by way of an XML file deployed with the plugin. If you are familiar with the Spring Framework's XML configuration, you will find Blueprint very similar. SolarNode uses the Eclipse Gemini implementation of the Blueprint specification, which is directly derived from Spring Framework.</p> <p>Note</p> <p>This guide will not document the full Blueprint XML syntax. Rather, it will attempt to showcase the most common parts used in SolarNode. Refer to the Blueprint Container Specification for full details of the specification.</p>"},{"location":"developers/osgi/blueprint/#example","title":"Example","text":"<p>Imagine you are working on a plugin and have a <code>com.example.Greeter</code> interface you would like to register as a service for other plugins to use, and an implementation of that service in  <code>com.example.HelloGreeter</code> that relies on the Placeholder  Service provided by SolarNode:</p> Greeter serviceHelloGreeter implementation <pre><code>package com.example;\npublic interface Greeter {\n\n/**\n     * Greet something with a given name.\n     * @param name the name to greet\n     * @return the greeting\n     */\nString greet(String name);\n\n}\n</code></pre> <pre><code>package com.example;\nimport net.solarnetwork.node.service.PlaceholderService;\npublic class HelloGreeter implements Greeter {\n\nprivate final PlaceholderService placeholderService;\n\npublic HelloGreeter(PlaceholderService placeholderService) {\nsuper();\nthis.placeholderService = placeholderService;\n}\n\n@Override\npublic String greet(String name) {\nreturn placeholderService.resolvePlaceholders(\nString.format(\"Hello %s, from {myName}.\", name),\nnull);\n}\n}\n</code></pre> <p>Assuming the <code>PlaceholderService</code> will resolve <code>{name}</code> to <code>Office Node</code>, we would expect the <code>greet()</code> method to run like this:</p> <pre><code>Greeter greeter = resolveGreeterService();\nString result = greeter.greet(\"Joe\");\n// result is \"Hello Joe, from Office Node.\"\n</code></pre> <p>In the plugin we then need to:</p> <ol> <li>Obtain a <code>net.solarnetwork.node.service.PlaceholderService</code> to pass to the     <code>HelloGreeter(PlaceholderService)</code> constructor</li> <li>Register  the <code>HelloGreeter</code> comopnent as a <code>com.example.Greeter</code> service in the SolarNode     platform</li> </ol> <p>Here is an example Blueprint XML document that does both:</p> Blueprint XML example<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\"&gt;\n\n&lt;!-- Declare a reference (lookup) to the PlaceholderService --&gt;\n&lt;reference id=\"placeholderService\"\ninterface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n\n&lt;service interface=\"com.example.Greeter\"&gt;\n&lt;bean class=\"com.example.HelloGreeter\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;/bean&gt;\n&lt;/service&gt;\n\n&lt;/blueprint&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#blueprint-xml-resources","title":"Blueprint XML Resources","text":"<p>Blueprint XML documents are added to a plugin's <code>OSGI-INF/blueprint</code> classpath location. A plugin can provide any number of Blueprint XML documents there, but often a single file is sufficient and a common convention in SolarNode is to name it <code>module.xml</code>.</p>"},{"location":"developers/osgi/blueprint/#xml-syntax","title":"XML Syntax","text":"<p>A minimal Blueprint XML file is structured like this:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\"&gt;\n\n&lt;!-- Plugin components configured here --&gt;\n\n&lt;/blueprint&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#service-references","title":"Service References","text":"<p>To make use of services registered by SolarNode plugins, you declare a reference to that service so you may refer to it elsewhere within the Blueprint XML. For example, imagine you wanted to use the Placeholder Service in your component. You would obtain a reference to that like this:</p> <pre><code>&lt;reference id=\"placeholderService\"\ninterface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n</code></pre> <p>The <code>id</code> attribute allows you to refer to this service elsewhere in your Blueprint XML, while <code>interface</code> declares the fully-qualified Java interface of the service you want to use.</p>"},{"location":"developers/osgi/blueprint/#components","title":"Components","text":"<p>Components in Blueprint are Java classes you would like instantiated when your plugin starts. They are declared using a <code>&lt;bean&gt;</code> element in Blueprint XML. You can assign each component a unique identifier using an <code>id</code> attribute, and then you can refer to that component in other components.</p> <p>Imagine an example component class <code>com.example.MyComponent</code>:</p> <pre><code>package com.example;\n\nimport net.solarnetwork.node.service.PlaceholderService;\n\npublic class MyComponent {\n\nprivate final PlaceholderService placeholderService;\nprivate int minimum;\n\npublic MyComponent(PlaceholderService placeholderService) {\nsuper();\nthis.placeholderService = placeholderService;\n}\n\npublic String go() {\nreturn PlaceholderService.resolvePlaceholders(placeholderService,\n\"{building}/temp\", null);\n}\n\npublic int getMinimum() {\nreturn minimum;\n}\n\npublic void setMinimum(int minimum) {\nthis.minimum = minimum;\n}\n}\n</code></pre> <p>Here is how that component could be declared in Blueprint:</p> <pre><code>&lt;reference id=\"placeholderService\"\ninterface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n\n&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;property name=\"minimum\" value=\"10\"/&gt;\n&lt;/bean&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#constructor-arguments","title":"Constructor Arguments","text":"<p>If your component requires any constructor arguments, they can be specified with nested <code>&lt;argument&gt;</code> elements in Blueprint. The <code>&lt;argument&gt;</code> value can be specified as a reference to another component using a <code>ref</code> attribute whose value is the <code>id</code> of that component, or as a literal value using a <code>value</code> attribute.</p> <p>For example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;argument value=\"10\"&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#property-accessors","title":"Property Accessors","text":"<p>You can configure mutable class properties on a component with nested <code>&lt;property name=\"\"&gt;</code> elements in Blueprint. A mutable property is a Java setter method. For example an <code>int</code> property <code>minimum</code> would be associated with a Java setter method <code>public void setMinimum(int value)</code>.</p> <p>The <code>&lt;property&gt;</code> value can be specified as a reference to another component using a <code>ref</code> attribute whose value is the <code>id</code> of that component, or as a literal value using a <code>value</code> attribute.</p> <p>For example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;property name=\"placeholderService\" ref=\"placeholderService\"&gt;\n&lt;argument name=\"minimum\" value=\"10\"&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#startstop-hooks","title":"Start/Stop Hooks","text":"<p>Blueprint can invoke a method on your component when it has finished instantiating and configuring the object (when the plugin starts), and another when it destroys the instance (when the plugin is stopped). You simply provide the name of the method you would like Blueprint to call in the <code>init-method</code> and <code>destroy-method</code> attributes of the <code>&lt;bean&gt;</code> element. For example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"\ninit-method=\"startup\"\ndestroy-method=\"shutdown\"&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#service-registration","title":"Service Registration","text":"<p>You can make any component available to other plugins by registering the component with a <code>&lt;service&gt;</code> element that declares what interface(s) your component provides. Once registered, other plugins can make use of your component, for example by declaring a <code>&lt;referenece&gt;</code> to your component class in their Blueprint XML.</p> <p>Note</p> <p>You can only register Java interfaces as services, not classes.</p> <p>For example, imagine a <code>com.example.Startable</code> interface like this:</p> <pre><code>package com.example;\npublic interface Startable {\n/**\n     * Start!\n     * @return the result\n     */\nString go();\n}\n</code></pre> <p>We could implement that interface in the <code>MyComponent</code> class, like this:</p> <pre><code>package com.example;\n\npublic class MyComponent implements Startable {\n\n@Override\npublic String go() {\nreturn \"Gone!\";\n}\n}\n</code></pre> <p>We can register <code>MyComponent</code> as a <code>Startable</code> service using a <code>&lt;service&gt;</code> element like this in Blueprint:</p> Direct service componentIndirect service component <pre><code>&lt;service interface=\"com.example.Startable\"&gt;\n&lt;!-- The service implementation is nested directly within --&gt;\n&lt;bean class=\"com.example.MyComponent\"/&gt;\n&lt;/service&gt;\n</code></pre> <pre><code>&lt;!-- The service implementation is referenced indirectly... --&gt;\n&lt;service ref=\"myComponent\" interface=\"com.example.Startable\"/&gt;\n\n&lt;!-- ... to a bean with a matching id attribute --&gt;\n&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"/&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#multiple-service-interfaces","title":"Multiple Service Interfaces","text":"<p>You can advertise any number of service interfaces that your component supports, by nesting an <code>&lt;interfaces&gt;</code> element within the <code>&lt;service&gt;</code> element, in place of the <code>interface</code> attribute. For example:</p> <pre><code>&lt;service ref=\"myComponent\"&gt;\n&lt;interfaces&gt;\n&lt;value&gt;com.example.Startable&lt;/value&gt;\n&lt;value&gt;com.example.Stopable&lt;/value&gt;\n&lt;/interfaces&gt;\n&lt;/service&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#export-service-packages","title":"Export service packages","text":"<p>For a registered service to be of any use to another plugin, the package the service is defined in must be exported by the plugin hosting that package. That is because the plugin wishing to add a reference to the service will need to import the package in order to use it.</p> <p>For example, the plugin that hosts the <code>com.example.service.MyService</code> service would need a manifest file that includes an <code>Export-Package</code> attribute similar to:</p> <pre><code>Export-Package: com.example.service;version=\"1.0.0\"\n</code></pre>"},{"location":"developers/osgi/life-cycle/","title":"Life cycle","text":"<p>Plugins in SolarNode can be added to and removed from the platform at any time without restarting the SolarNode process, because of the Life Cycle process OSGi manages. The life cycle of a plugin consists of a set of states and OSGi will transition a plugin's state over the course of the plugin's life.</p> <p>The available plugin states are:</p> State Description <code>INSTALLED</code> The plugin has been successfully added to the OSGi framework. <code>RESOLVED</code> All package dependencies that the bundle needs are available. This state indicates that the plugin is either ready to be started or has stopped. <code>STARTING</code> The plugin is being started by the OSGi framework, but it has not finished starting yet. <code>ACTIVE</code> The plugin has been successfully started and is running. <code>STOPPING</code> The plugin is being stopped by the OSGi framework, but it has not finished stopping yet. <code>UNINSTALLED</code> The plugin has been removed by the OSGi framework. It cannot change to another state. <p>The possible changes in state can be visualized in the following state-change diagram:</p> Faisal.akeel, Public domain, via Wikimedia Common"},{"location":"developers/osgi/life-cycle/#activator","title":"Activator","text":"<p>A plugin can opt in to receiving callbacks for the start/stop state transitions by providing an <code>org.osgi.framework.BundleActivator</code> implementation and declaring that class in the <code>Bundle-Activator</code> manifest attribute. This can be useful when a plugin needs to initialize some resources when the plugin is started, and then release those resources when the plugin is stopped.</p> BundleActivator APIBundleActivator implementation exampleManifest declaration example <pre><code>public interface BundleActivator {\n/**\n     * Called when this bundle is started so the Framework can perform the\n     * bundle-specific activities necessary to start this bundle.\n     *\n     * @param context The execution context of the bundle being started.\n     */\npublic void start(BundleContext context) throws Exception;\n\n/**\n     * Called when this bundle is stopped so the Framework can perform the\n     * bundle-specific activities necessary to stop the bundle.\n     *\n     * @param context The execution context of the bundle being stopped.\n     */\npublic void stop(BundleContext context) throws Exception;\n}\n</code></pre> <pre><code>package com.example.activator;\nimport org.osgi.framework.BundleActivator;\nimport org.osgi.framework.BundleContext;\npublic class Activator implements BundleActivator {\n\n@Override\npublic void start(BundleContext bundleContext) throws Exception {\n// initialize resources here\n}\n\n@Override\npublic void stop(BundleContext bundleContext) throws Exception {\n// clean up resources here\n}\n}\n</code></pre> <pre><code>Manifest-Version: 1.0\nBundle-ManifestVersion: 2\nBundle-Name: Example Activator\nBundle-SymbolicName: com.example.activator\nBundle-Version: 1.0.0\nBundle-Activator: com.example.activator.Activator\nImport-Package: org.osgi.framework;version=\"[1.3,2.0)\"\n</code></pre> <p>Tip</p> <p>Often making use of the component life cycle hooks available in Blueprint are sufficient and no <code>BundleActivator</code> is necessary.</p>"},{"location":"developers/osgi/manifest/","title":"Manifest","text":"<p>As SolarNode plugins are OSGi bundles, which are Java JAR files, every plugin automatically includes a <code>META-INF/MANIFEST.MF</code> file as defined in the Java JAR File Specification. The <code>MANIFEST.MF</code> file is where OSGi metadata is included, turning the JAR into an OSGi bundle (plugin).</p>"},{"location":"developers/osgi/manifest/#example","title":"Example","text":"<p>Here is an example snippet from the SolarNode net.solarnetwork.common.jdt plugin:</p> Example plugin MANIFEST.MF<pre><code>Manifest-Version: 1.0\nBundle-ManifestVersion: 2\nBundle-Name: Java Compiler Service (JDT)\nBundle-SymbolicName: net.solarnetwork.common.jdt\nBundle-Description: Java complier using Eclipse JDT.\nBundle-Version: 3.0.0\nBundle-Vendor: SolarNetwork\nBundle-RequiredExecutionEnvironment: JavaSE-1.8\nBundle-Activator: net.solarnetwork.common.jdt.Activator\nExport-Package:\nnet.solarnetwork.common.jdt;version=\"2.0.0\"\nImport-Package:\nnet.solarnetwork.service;version=\"[1.0,2.0)\",\norg.eclipse.jdt.core.compiler,\norg.eclipse.jdt.internal.compiler,\norg.osgi.framework;version=\"[1.5,2.0)\",\norg.slf4j;version=\"[1.7,2.0)\",\norg.springframework.context;version=\"[5.3,6.0)\",\norg.springframework.core.io;version=\"[5.3,6.0)\",\norg.springframework.util;version=\"[5.3,6.0)\"\n</code></pre> <p>The rest of this document will describe this structure in more detail.</p>"},{"location":"developers/osgi/manifest/#versioning","title":"Versioning","text":"<p>In OSGi plugins are always versioned and and Java packages may be versioned. Versions follow Semantic Versioning rules, generally using this syntax:</p> <pre><code>major.minor.patch\n</code></pre> <p>In the manifest example you can see the plugin version <code>3.0.0</code> declared in the <code>Bundle-Version</code> attribute:</p> <pre><code>Bundle-Version: 3.0.0\n</code></pre> <p>The example also declares (exports) a <code>net.solarnetwork.common.jdt</code> package for other plugins to import (use) as version <code>2.0.0</code>, in the <code>Export-Package</code> attribute:</p> <pre><code>Export-Package:\nnet.solarnetwork.common.jdt;version=\"2.0.0\"\n</code></pre> <p>The example also uses (imports) a versioned package <code>net.solarnetwork.service</code> using a version range greater than or equal to <code>1.0</code> and less than <code>2.0</code> and an unversioned package <code>org.eclipse.jdt.core.compiler</code>, in the <code>Import-Package</code> attribute:</p> <pre><code>Import-Package:\nnet.solarnetwork.service;version=\"[1.0,2.0)\",\norg.eclipse.jdt.core.compiler,\n</code></pre> <p>Tip</p> <p>Some plugins, and core Java system packages, do not declare package versions. You should declare package versions in your own plugins.</p>"},{"location":"developers/osgi/manifest/#version-ranges","title":"Version ranges","text":"<p>Some OSGi version attributes allow version ranges to be declared, such as the <code>Import-Package</code> attribute. A version range is a comma-delimited <code>lower,upper</code> specifier. Square brackets are used to represent inclusive  values and round brackets represent exclusive values. A value can be omitted to reprsent an unbounded value. Here are some examples:</p> Range Logic Description <code>[1.0,2.0)</code> 1.0.0 \u2264 x &lt; 2.0.0 Greater than or equal to <code>1.0.0</code> and less than <code>2.0.0</code> <code>(1,3)</code> 1.0.0 &lt; x &lt; 3.0.0 Greater than <code>1.0.0</code> and less than <code>3.0.0</code> <code>[1.3.2,)</code> 1.3.2 \u2264 x Greater than or eequal to <code>1.3.2</code> <code>1.3.2</code> 1.3.2 \u2264 x Greater than or eequal to <code>1.3.2</code> (shorthand notation) <p>Implied unbounded range</p> <p>An inclusive lower, unbounded upper range can be specifeid using a shorthand notation of just the lower bound, like <code>1.3.2</code>.</p>"},{"location":"developers/osgi/manifest/#required-attributes","title":"Required attributes","text":"<p>Each plugin must provide the following attributes:</p> Attribute Example Description <code>Bundle-ManifestVersion</code> 2 declares the OSGi bundle manifest version; always <code>2</code> <code>Bundle-Name</code> Awesome Data Source a concise human-readable name for the plugin <code>Bundle-SymbolicName</code> com.example.awesome a machine-readable, universally unique identifier for the plugin <code>Bundle-Version</code> 1.0.0 the plugin version <code>Bundle-RequiredExecutionEnvironment</code> JavaSE-1.8 a required OSGi execution environment"},{"location":"developers/osgi/manifest/#recommended-attributes","title":"Recommended attributes","text":"<p>Each plugin is recommended to provide the following attributes:</p> Attribute Example Description <code>Bundle-Description</code> An awesome data source that collects awesome data. a longer human-readable description of the plugin <code>Bundle-Vendor</code> ACME Corp the name of the entity or organisation that authored the plugin"},{"location":"developers/osgi/manifest/#common-attributes","title":"Common attributes","text":"<p>Other common manifest attributes are:</p> Attribute Example Description <code>Bundle-Activator</code> com.example.awesome.Activator a fully-qualified Java class name that implements the <code>org.osgi.framework.BundleActivator</code> interface, to handle plugin lifecycle events; see Activator for more information <code>Export-Package</code> net.solarnetwork.common.jdt;version=\"2.0.0\" a package export list <code>Import-Package</code> net.solarnetwork.service;version=\"[1.0,2.0)\" a package dependency list"},{"location":"developers/osgi/manifest/#package-dependencies","title":"Package dependencies","text":"<p>A plugin must declare the Java packages it directly uses in a <code>Import-Package</code> attribute. This attribute accpets a comma-delimited list of package specifications that take the basic form of:</p> <pre><code>PACKAGE;version=\"VERSION\"\n</code></pre> <p>For example here is how the <code>net.solarnetwork.service</code> package, versioned between <code>1.0</code> and <code>2.0</code>, would be declared:</p> <pre><code>Import-Package: net.solarnetwork.service;version=\"[1.0,2.0)\"\n</code></pre> <p>Direct package use means your plugin has code that imports a class from a given package. Classes in an imported package may import other packages indirectly; you do not need to import those packages as well.  For example if you have code like this:</p> <pre><code>import net.solarnetwork.service.OptionalService;\n</code></pre> <p>Then you will need to import the <code>net.solarnetwork.service</code> package.</p> <p>Note</p> <p>The SolarNode platform automatically imports core Java packages like <code>java.*</code> so you do not need to declare those.</p> <p>Also note that in some scenarios a package used by a class in an imported package becomes a direct dependency. For example when you extend a class from an imported package and that class imports other packages. Those other packages may become direct dependencies that you also need to import.</p>"},{"location":"developers/osgi/manifest/#child-package-dependencies","title":"Child package dependencies","text":"<p>If you import a package in your plugin, any child packages that may exist are not imported as well. You must import every individual package you need to use in your plugin.</p> <p>For example to use both <code>net.solarnetwork.service</code> and <code>net.solarnetwork.service.support</code> you would have an <code>Import-Package</code> attribute like this:</p> <pre><code>Import-Package:\nnet.solarnetwork.service;version=\"[1.0,2.0)\",\nnet.solarnetwork.service.support;version=\"[1.1,2.0)\"\n</code></pre>"},{"location":"developers/osgi/manifest/#package-exports","title":"Package exports","text":"<p>A plugin can export any package it provides, making the resources within that package available to other plugins to import and use. Declare exoprted packages with a <code>Export-Package</code> attribute. This attribute takes a comma-delimited list of versioned package specifications. Note that version ranges are not supported: you must declare the exact version of the package you are exporting. For example:</p> <pre><code>Export-Package: com.example.service;version=\"1.0.0\"\n</code></pre> <p>Note</p> <p>Exported packages should not be confused with services. Exported packages give other plugins access to the classes and any other resources within those packages, but do not provide services to the platform. You can use Blueprint to register services. Keep in mind that any service a plugin registers must exist within an exported package to be of any use.</p>"},{"location":"developers/services/closeable-service/","title":"Closeable Service","text":"<p>A plugin can publish a <code>net.solarnetwork.service.CloseableService</code> and SolarNode will invoke the <code>closeService()</code> method on it when that service is destroyed. This can be useful in some situations, to make sure resources are freed when a service is no longer needed.</p> <p>Blueprint does provide the <code>destroy-method</code> stop hook that can be used in many situations, however Blueprint does not allow this in all cases. For example a <code>&lt;bean&gt;</code> nested within a <code>&lt;service&gt;</code> element does not allow a <code>destroy-method</code>:</p> <pre><code>&lt;service interface=\"com.example.MyService\"&gt;\n&lt;!-- destroy-method not allowed here: --&gt;\n&lt;bean class=\"com.example.MyComponent\"/&gt;\n&lt;/service&gt;\n</code></pre> <p>If <code>MyComponent</code> also implemented <code>CloseableService</code> then we can achieve the desired stop hook like this:</p> <pre><code>&lt;service&gt;\n&lt;interfaces&gt;\n&lt;value&gt;com.example.MyService&lt;/value&gt;\n&lt;value&gt;net.solarnetwork.service.CloseableService&lt;/value&gt;\n&lt;/interfaces&gt;\n&lt;bean class=\"com.example.MyComponent\"/&gt;\n&lt;/service&gt;\n</code></pre> <p>Note</p> <p>Note that the above example <code>CloseableService</code> is not strictly needed, as the same effect could be acheived by un-nesting the <code>&lt;bean&gt;</code> from the <code>&lt;service&gt;</code> element, like this:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\" destroy-method=\"close\"/&gt;\n&lt;service ref=\"myComponent\" interface=\"com.example.MyService\"/&gt;\n</code></pre> <p>There are situations where un-nesting is not possible, which is where <code>CloseableService</code> can be helpful.</p>"},{"location":"developers/services/job-scheduler/","title":"Job Scheduler","text":"<p>SolarNode provides a Job Scheduler service that can automatically schedule and execute jobs exported by plugins.</p>"},{"location":"developers/services/job-scheduler/#configuration","title":"Configuration","text":"<p>The Job Scheduler supports the following configuration properties in the <code>net.solarnetwork.node.core</code> namespace:</p> Property Default Description <code>jobScheduler.poolSize</code> 10 The number of threads to maintain in the job scheduler, and thus the maximum number of jobs that can run simultaneously. Must be set to 1 or higher. <code>scheduler.startupDelay</code> 180 A delay in seconds after creating the job scheduler to start triggering jobs. This can be useful to give the application time to completely initialize before starting to run jobs."},{"location":"developers/services/placeholder-service/","title":"Placeholder Service","text":"<p>The Placeholder Service API provides components a way to resolve variables in strings, known as placeholders, whose values are managed outside the component itself. For example a datum data source plugin could use the Placeholder Service to support resolving placeholders in a configurable Source ID property.</p> <p>SolarNode provides a Placeholder Service implementation that resolves both dynamic placeholders from the Settings Database (using the setting namespace <code>placeholder</code>), and static placeholders from a configurable file or directory location.</p>"},{"location":"developers/services/placeholder-service/#use","title":"Use","text":"<p>Call the <code>resolvePlaceholders(s, parameters)</code> method to resolve all placeholders on the String <code>s</code>. The <code>parameters</code> argument can be used to provide additional placeholder values, or you can pass just pass <code>null</code> to rely solely on the placeholders available in the service already.</p>"},{"location":"developers/services/placeholder-service/#example","title":"Example","text":"<p>Here is an imaginary class that is constructed with an optional <code>PlaceholderService</code>, and then when the <code>go()</code> method is called uses that to resolve placeholders in the string <code>{building}/temp</code> and return the result:</p> <pre><code>package com.example;\n\nimport net.solarnetwork.node.service.PlaceholderService;\nimport net.solarnetwork.service.OptionalService;\n\npublic class MyComponent {\n\nprivate final OptionalService&lt;PlaceholderService&gt; placeholderService;\n\npublic MyComponent(OptionalService&lt;PlaceholderService&gt; placeholderService) {\nsuper();\nthis.placeholderService = placeholderService;\n}\n\npublic String go() {\nreturn PlaceholderService.resolvePlaceholders(placeholderService,\n\"{building}/temp\", null);\n}\n}\n</code></pre>"},{"location":"developers/services/placeholder-service/#blueprint","title":"Blueprint","text":"<p>To use the Placeholder Service in your component, add either an Optional Service or explicit reference to your plugin's Blueprint XML file like this (depending on what your plugin requires):</p> Optional ServiceExplicit Reference <pre><code>&lt;bean id=\"placeholderService\" class=\"net.solarnetwork.common.osgi.service.DynamicServiceTracker\"&gt;\n&lt;argument ref=\"bundleContext\"/&gt;\n&lt;property name=\"serviceClassName\" value=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n&lt;property name=\"sticky\" value=\"true\"/&gt;\n&lt;/bean&gt;\n</code></pre> <pre><code>&lt;reference id=\"placeholderService\" interface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n</code></pre> <p>Then inject that service into your component's <code>&lt;bean&gt;</code>, for example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;/bean&gt;\n</code></pre>"},{"location":"developers/services/placeholder-service/#configuration","title":"Configuration","text":"<p>The Placeholder Service supports the following configuration properties in the <code>net.solarnetwork.node.core</code> namespace:</p> Property Default Description <code>placeholders.dir</code> ${CONF_DIR}/placeholders.d Path to a single propertites file or to a directory of properties files to load as static placeholder parameter values when SolarNode starts up."},{"location":"developers/services/settings-db/","title":"Settings Database","text":""},{"location":"developers/services/settings-service/","title":"Settings Service","text":"<p>TODO</p>"},{"location":"developers/settings/","title":"Settings","text":"<p>SolarNode provides a way for plugin components to describe their user-configurable properties, called settings, to the platform. SolarNode provides a web-based GUI that makes it easy for users to configure those components using a web browser. For example, here is a screen shot of the SolarNode GUI showing a form for the settings of a Database Backup component:</p> <p></p> <p>The mechanism for components to describe themselves in this way is called the Settings API. Classes that wish to participate in this system publish metadata about their configurable properties through the Settings Provider API, and then SolarNode generates a GUI form based on that metadata. Each form field in the previous example image is a Setting Specifier.</p> <p>The process is similar to the built-in Settings app on iOS: iOS applications can publish configurable property definitions and the Settings app displays a GUI that allows users to modify those properties.</p>"},{"location":"developers/settings/factory/","title":"Factory Service","text":""},{"location":"developers/settings/provider/","title":"Settings Provider","text":"<p>The <code>net.solarnetwork.settings.SettingSpecifierProvider</code> interface defines the way a class can declare themselves as a user-configurable component. The main elements of this API are:</p> <pre><code>public interface SettingSpecifierProvider {\n\n/**\n     * Get a unique, application-wide setting ID.\n     *\n     * @return unique ID\n     */\nString getSettingUid();\n\n/**\n     * Get a non-localized display name.\n     *\n     * @return non-localized display name\n     */\nString getDisplayName();\n\n/**\n     * Get a list of {@link SettingSpecifier} instances.\n     *\n     * @return list of {@link SettingSpecifier}\n     */\nList&lt;SettingSpecifier&gt; getSettingSpecifiers();\n\n}\n</code></pre> <p>The <code>getSettingUid()</code> method defines a unique ID for the configurable component. By convention the class or package name of the component (or a derivative of it) is used as the ID.</p> <p>The <code>getSettingSpecifiers()</code> method returns a list of all the configurable properties of the component, as a list of Setting Specifier instances.</p>"},{"location":"developers/settings/provider/#setting-accessors","title":"Setting accessors","text":"<p>s <pre><code>@Override\nprivate String username;\n\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;(1);\n\n// expose a \"username\" setting with a default value of \"admin\"\nresults.add(new BasicTextFieldSettingSpecifier(\"username\", \"admin\"));\n\nreturn results;\n}\n\n// settings are updated at runtime via standard setter methods\npublic void setUsername(String username) {\nthis.username = username;\n}\n</code></pre></p> <p>Setting values are treated as strings within the Settings API, but the methods associated with settings can accept any primitive or standard number type like <code>int</code> or <code>Integer</code> as well.</p> BigDecimal setting example<pre><code>@Override\nprivate BigDecimal num;\n\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;(1);\n\nresults.add(new BasicTextFieldSettingSpecifier(\"num\", null));\n\nreturn results;\n}\n\n// settings will be coerced from strings into basic types automatically\npublic void setNum(BigDecimal num) {\nthis.num = num;\n}\n</code></pre>"},{"location":"developers/settings/provider/#proxy-setting-accessors","title":"Proxy setting accessors","text":"<p>Sometimes you might like to expose a simple string setting but internally treat the string as a more complex type. For example a <code>Map</code> could be configured using a simple delimited string like <code>key1 = val1, key2 = val2</code>. For situations like this you can publish a proxy setting that manages a complex data type as a string, and en/decode the complex type in your component accessor methods.</p> Delimited string to Map setting example<pre><code>@Override\nprivate Map&lt;String, String&gt; map;\n\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;(1);\n\n// expose a \"mapping\" proxy setting for the map field\nresults.add(new BasicTextFieldSettingSpecifier(\"mapping\", null));\n\nreturn results;\n}\n\npublic void setMapping(String mapping) {\nthis.map = StringUtils.commaDelimitedStringToMap(mapping);\n}\n</code></pre>"},{"location":"developers/settings/resource-handler/","title":"Setting Resource Handler","text":"<p>The <code>net.solarnetwork.node.settings.SettingResourceHandler</code> API defines a way for a component to import and export files uploaded to SolarNode from external sources.</p> <p>A component could support importing a file using the File setting. This could be used, to provide a way of configuring the component from a configuration file, like CSV, JSON, XML, and so on. Similarly a component could support exporting a file, to generate a configuration file in another format like CSV, JSON, XML, and so on, from its current settings. For example, the Modbus Device Datum Source does exactly these things: importing and exporting a custom CSV file to make configuring the component easier.</p>"},{"location":"developers/settings/resource-handler/#importing","title":"Importing","text":"<p>The main part of the <code>SettingResourceHandler</code> API for importing files looks like this:</p> <pre><code>public interface SettingResourceHandler {\n\n/**\n     * Get a unique, application-wide setting ID.\n     *\n     * &lt;p&gt;\n     * This ID must be unique across all setting resource handlers registered\n     * within the system. Generally the implementation will also be a\n     * {@link net.solarnetwork.settings.SettingSpecifierProvider} for the same\n     * ID.\n     * &lt;/p&gt;\n     *\n     * @return unique ID\n     */\nString getSettingUid();\n\n/**\n     * Apply settings for a specific key from a resource.\n     *\n     * @param settingKey\n     *        the setting key, generally a\n     *        {@link net.solarnetwork.settings.KeyedSettingSpecifier#getKey()}\n     *        value\n     * @param resources\n     *        the resources with the settings to apply\n     * @return any setting values that should be persisted as a result of\n     *         applying the given resources (never {@literal null}\n     * @throws IOException\n     *         if any IO error occurs\n     */\nSettingsUpdates applySettingResources(String settingKey, Iterable&lt;Resource&gt; resources)\nthrows IOException;\n</code></pre> <p>The <code>getSettingUid()</code> method overlaps with the Settings Provider API, and as the comments note it is typical for a Settings Provider that publishes settings like File or Text Area to also implement <code>SettingResourceHandler</code>.</p> <p>The <code>settingKey</code> passed to the <code>applySettingResources()</code> method identifies the resource(s) being uploaded, as a single Setting Resource Handler might support multiple resources. For example a Settings Provider might publish multiple File settings, or File and Text Area settings. The <code>settingKey</code> is used to differentiate between each one.</p>"},{"location":"developers/settings/resource-handler/#importing-example","title":"Importing example","text":"<p>Imagine a component that publishes a File setting. A typical implementation of that component would look like this (this example omits some methods for brevity):</p> <pre><code>public class MyComponent implements SettingSpecifierProvider,\nSettingResourceHandler {\n\nprivate static final Logger log\n= LoggerFactory.getLogger(MyComponent.class);\n\n/** The resource key to identify the File setting resource. */\npublic static final String RESOURCE_KEY_DOCUMENT = \"document\";\n\n@Override\npublic String getSettingUid() {\nreturn \"com.example.mycomponent\";\n}\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;();\n\n// publish a File setting tied to the RESOURCE_KEY_DOCUMENT key,\n// allowing only text files to be accepted\nresults.add(new BasicFileSettingSpecifier(RESOURCE_KEY_DOCUMENT, null,\nnew LinkedHashSet&lt;&gt;(asList(\".txt\", \"text/*\")), false));\n\nreturn results;\n}\n\n@Override\npublic SettingsUpdates applySettingResources(String settingKey,\nIterable&lt;Resource&gt; resources) throws IOException {\nif ( resources == null ) {\nreturn null;\n}\nif ( RESOURCE_KEY_DOCUMENT.equals(settingKey) ) {\nfor ( Resource r : resources ) {\n// here we would do something useful with the resource... like\n// read into a string and log it\nString s = FileCopyUtils.copyToString(new InputStreamReader(\nr.getInputStream(), StandardCharsets.UTF_8));\n\nlog.info(\"Got {} resource content: {}\", settingKey, s);\n\nbreak; // only accept one file\n}\n}\nreturn null;\n}\n\n}\n</code></pre>"},{"location":"developers/settings/resource-handler/#exporting","title":"Exporting","text":"<p>The part of the Setting Resource Handler API that supports exporting setting resources looks like this:</p> <pre><code>    /**\n     * Get a list of supported setting keys for the\n     * {@link #currentSettingResources(String)} method.\n     *\n     * @return the set of supported keys\n     */\ndefault Collection&lt;String&gt; supportedCurrentResourceSettingKeys() {\nreturn Collections.emptyList();\n}\n\n/**\n     * Get the current setting resources for a specific key.\n     *\n     * @param settingKey\n     *        the setting key, generally a\n     *        {@link net.solarnetwork.settings.KeyedSettingSpecifier#getKey()}\n     *        value\n     * @return the resources, never {@literal null}\n     */\nIterable&lt;Resource&gt; currentSettingResources(String settingKey);\n</code></pre> <p>The <code>supportedCurrentResourceSettingKeys()</code> method returns a set of resource keys the component supports for exporting. The <code>currentSettingResources()</code> method returns the resources to export for a given key.</p> <p>The SolarNode GUI shows a form menu with all the available resources for all components that support the <code>SettingResourceHandler</code> API, and lets the user to download them:</p> <p></p>"},{"location":"developers/settings/resource-handler/#exporting-example","title":"Exporting example","text":"<p>Here is an example of a component that supports exporting a CSV file resource based on the component's current configuration:</p> <pre><code>public class MyComponent implements SettingSpecifierProvider,\nSettingResourceHandler {\n\n/** The setting resource key for a CSV configuration file. */\npublic static final String RESOURCE_KEY_CSV_CONFIG = \"csvConfig\";\n\nprivate int max = 1;\nprivate boolean enabled = true;\n\n@Override\npublic Collection&lt;String&gt; supportedCurrentResourceSettingKeys() {\nreturn Collections.singletonList(RESOURCE_KEY_CSV_CONFIG);\n}\n\n@Override\npublic Iterable&lt;Resource&gt; currentSettingResources(String settingKey) {\nif ( !RESOURCE_KEY_CSV_CONFIG.equals(settingKey) ) {\nreturn null;\n}\n\nStringBuilder buf = new StringBuilder();\nbuf.append(\"max,enabled\\r\\n\");\nbuf.append(max).append(',').append(enabled).append(\"\\r\\n\");\n\nreturn Collections.singleton(new ByteArrayResource(\nbuf.toString().getBytes(UTF_8), \"My Component CSV Config\") {\n\n@Override\npublic String getFilename() {\nreturn \"my-component-config.csv\";\n}\n\n});\n}\n}\n</code></pre>"},{"location":"developers/settings/singleton/","title":"Singleton Service","text":""},{"location":"developers/settings/specifier/","title":"Setting Specifier","text":"<p>The <code>net.solarnetwork.settings.SettingSpecifier</code> API defines metadata for a single configurable property in the Settings API. The API looks like this:</p> <pre><code>public interface SettingSpecifier {\n\n/**\n     * A unique identifier for the type of setting specifier this represents.\n     *\n     * &lt;p&gt;\n     * Generally this will be a fully-qualified interface name.\n     * &lt;/p&gt;\n     *\n     * @return the type\n     */\nString getType();\n\n/**\n     * Localizable text to display with the setting's content.\n     *\n     * @return the title\n     */\nString getTitle();\n\n}\n</code></pre> <p>This interface is very simple, and extended by more specialized interfaces that form more useful setting types.</p> <p>Note</p> <p>A <code>SettingSpecifier</code> instance is often referred to simply as a setting.</p> <p>Here is a view of the class hierarchy that builds off of this interface:</p> <p></p> <p>Note</p> <p>The <code>SettingSpecifier</code> API defines metadata about a configurable property, but not methods to view or change that property's value. The Settings Service provides methods for managing setting values.</p>"},{"location":"developers/settings/specifier/#settings-playpen","title":"Settings Playpen","text":"<p>The Settings Playpen plugin demonstrates most of the available setting types, and is a great way to see how the settings can be used.</p>"},{"location":"developers/settings/specifier/#text-field","title":"Text Field","text":"<p>The <code>TextFieldSettingSpecifier</code> defines a simple string-based configurable property and is the most common setting type. The setting defines a <code>key</code> that maps to a setter method on its associated component class. In the SolarNode GUI a text field is rendered as an HTML form text input, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicTextFieldSettingSpecifier</code> class provides the standard implementation of this API. A standard text field setting is created like this:</p> <pre><code>new BasicTextFieldSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\");\n\n// or without any default value\nnew BasicTextFieldSettingSpecifier(\"myProperty\", null);\n</code></pre> <p>Tip</p> <p>Setting values are generally treated as strings within the Settings API, however other basic data types such as integers and numbers can be used as well. You can also publish a \"proxy\" setting that manages a complex data type as a string, and en/decode the complex type in your component accessor methods.</p> <p>For example a <code>Map&lt;String, String&gt;</code> setting could be published as a text field setting that en/decodes the <code>Map</code> into a delimited string value, for example <code>name=Test, color=red</code>.</p>"},{"location":"developers/settings/specifier/#secure-text-field","title":"Secure Text Field","text":"<p>The <code>BasicTextFieldSettingSpecifier</code> can also be used for \"secure\" text fields where the field's content is obscured from view. In the SolarNode GUI a secure text field is rendered as an HTML password form input like this:</p> <p></p> <p>A standard secure text field setting is created by passing a third <code>true</code> argument, like this:</p> <pre><code>new BasicTextFieldSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\", true);\n\n// or without any default value\nnew BasicTextFieldSettingSpecifier(\"myProperty\", null, true);\n</code></pre>"},{"location":"developers/settings/specifier/#title","title":"Title","text":"<p>The <code>TitleSettingSpecifier</code> defines a simple read-only string-based configurable property. The setting defines a <code>key</code> that maps to a setter method on its associated component class. In the SolarNode GUI the default value is rendered as plain text, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicTitleSettingSpecifier</code> class provides the standard implementation of this API. A standard title setting is created like this:</p> <pre><code>new BasicTitleSettingSpecifier(\"status\", \"Status is good.\", true);\n</code></pre>"},{"location":"developers/settings/specifier/#html-title","title":"HTML Title","text":"<p>The <code>TitleSettingSpecifier</code> supports HTML markup. In the SolarNode GUI the default value is rendered directly into HTML, like this:</p> <p></p> <pre><code>// pass `true` as the 4th argument to enable HTML markup in the status value\nnew BasicTitleSettingSpecifier(\"status\", \"Status is &lt;b&gt;good&lt;/b&gt;.\", true, true);\n</code></pre>"},{"location":"developers/settings/specifier/#text-area","title":"Text Area","text":"<p>The <code>TextAreaSettingSpecifier</code> defines a simple string-based configurable property for a larger text value, loaded as an external file using the SettingResourceHandler API. In the SolarNode GUI a text area is rendered as an HTML form text area with an associated button to upload the content, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicTextAreaSettingSpecifier</code> class provides the standard implementation of this API. A standard text field setting is created like this:</p> <pre><code>new BasicTextAreaSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\");\n\n// or without any default value\nnew BasicTextAreaSettingSpecifier(\"myProperty\", null);\n</code></pre>"},{"location":"developers/settings/specifier/#direct-text-area","title":"Direct Text Area","text":"<p>The <code>BasicTextAreaSettingSpecifier</code> can also be used for \"direct\" text areas where the field's content is not uploaded as an external file. In the SolarNode GUI a direct text area is rendered as an HTML form text area, like this:</p> <p></p> <p>A standard direct text area setting is created by passing a third <code>true</code> argument, like this:</p> <pre><code>new BasicTextAreaSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\", true);\n\n// or without any default value\nnew BasicTextAreaSettingSpecifier(\"myProperty\", null, true);\n</code></pre>"},{"location":"developers/settings/specifier/#toggle","title":"Toggle","text":"<p>The <code>ToggleSettingSpecifier</code> defines a boolean configurable property. In the SolarNode GUI a toggle setting is rendered as an HTML form button, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicToggleSettingSpecifier</code> class provides the standard implementation of this API. A standard toggle setting is created like this:</p> <pre><code>new BasicToggleSettingSpecifier(\"enabled\", false); // default \"off\"\n\nnew BasicToggleSettingSpecifier(\"enabled\", true);  // default \"on\"\n</code></pre>"},{"location":"developers/settings/specifier/#slider","title":"Slider","text":"<p>The <code>SliderSettingSpecifier</code> defines a number-based configuration property with minimum and maximum values enforced, and a step limit. In the SolarNode GUI a slider is rendered as an HTML widget, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicSliderSettingSpecifier</code> class provides the standard implementation of this API. A standard Slider setting is created like this:</p> <pre><code>// no default value, range between 0-11 in 0.5 increments\nnew BasicSliderSettingSpecifier(\"volume\", null, 0.0, 11.0, 0.5);\n\n// default value 5.0, range between 0-11 in 0.5 increments\nnew BasicSliderSettingSpecifier(\"volume\", 5.0, 0.0, 11.0, 0.5);\n</code></pre>"},{"location":"developers/settings/specifier/#radio-group","title":"Radio Group","text":"<p>The <code>RadioGroupSettingSpecifier</code> defines a configurable property that accepts a single value from a fixed set of possible values. In the SolarNode GUI a radio group is rendered as a set of HTML radio input form fields, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicRadioGroupSettingSpecifier</code> class provides the standard implementation of this API. A standard RadioGroup setting is created like this:</p> <pre><code>String[] vals = new String[] {\"a\", \"b\", \"c\"};\nString[] labels = new Strign[] {\"One\", \"Two\", \"Three\"};\nMap&lt;String, String&gt; radioValues = new LinkedHashMap&lt;&gt;(3);\nfor ( int i = 0; i &lt; vals.length; i++ ) {\nradioValues.put(vals[i], labels[i]);\n}\nBasicRadioGroupSettingSpecifier radio =\nnew BasicRadioGroupSettingSpecifier(\"option\", vals[0]);\nradio.setValueTitles(radioValues);\n</code></pre>"},{"location":"developers/settings/specifier/#multi-value","title":"Multi-value","text":"<p>The <code>MultiValueSettingSpecifier</code> defines a configurable property that accepts a single value from a fixed set of possible values. In the SolarNode GUI a multi-value setting is rendered as an HTML select form field, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicMultiValueSettingSpecifier</code> class provides the standard implementation of this API. A standard MultiValue setting is created like this:</p> <pre><code>String[] vals = new String[] {\"a\", \"b\", \"c\"};\nString[] labels = new Strign[] {\"Option 1\", \"Option 2\", \"Option 3\"};\nMap&lt;String, String&gt; radioValues = new LinkedHashMap&lt;&gt;(3);\nfor ( int i = 0; i &lt; vals.length; i++ ) {\nradioValues.put(vals[i], labels[i]);\n}\nBasicMultiValueSettingSpecifier menu = new BasicMultiValueSettingSpecifier(\"option\",\nvals[0]);\nmenu.setValueTitles(menuValues);\n</code></pre>"},{"location":"developers/settings/specifier/#file","title":"File","text":"<p>The <code>FileSettingSpecifier</code> defines a file-based resource property, loaded as an external file using the SettingResourceHandler API. In the SolarNode GUI a file setting is rendered as an HTML file input, like this:</p> <p></p> <p>The <code>net.solarnetwork.node.settings.support.BasicFileSettingSpecifier</code> class provides the standard implementation of this API. A standard file setting is created like this:</p> <pre><code>// a single file only, no default content\nnew BasicFileSettingSpecifier(\"document\", null,\nnew LinkedHashSet&lt;&gt;(Arrays.asList(\".txt\", \"text/*\")), false);\n\n// multiple files allowed, no default content\nnew BasicFileSettingSpecifier(\"document-list\", null,\nnew LinkedHashSet&lt;&gt;(Arrays.asList(\".txt\", \"text/*\")), true);\n</code></pre>"},{"location":"developers/settings/specifier/#dynamic-list","title":"Dynamic List","text":"<p>A Dynamic List setting allows the user to manage a list of homogeneous items, adding or subtracting items as desired. The items can be literals like strings, or arbitrary objects that define their own settings. In the SolarNode GUI a dynamic list setting is rendered as a pair of HTML buttons to remove and add items, like this:</p> <p></p> <p>A Dynamic List is often backed by a Java <code>Collection</code> or array in the associated component. In addition a special size-adjusting accessor method is required, named after the setter method with <code>Count</code> appended. SolarNode will use this accessor to request a specific size for the dynamic list.</p> Array-backed dynamic list accessorsList-backed dynamic list accessors <pre><code>private String[] names = new String[0];\n\npublic String[] getNames() {\nreturn names;\n}\n\npublic void setNames(String[] names) {\nthis.names = names;\n}\n\npublic int getNamesCount() {\nString[] l = getNames();\nreturn (l == null ? 0 : l.length);\n}\n\npublic void setNamesCount(int count) {\nsetNames(ArrayUtils.arrayOfLength(\ngetNames(), count, String.class, String::new));\n}\n</code></pre> <pre><code>private List&lt;String&gt; names = new ArrayList&lt;&gt;();\n\npublic List&lt;String&gt; getNames() {\nreturn names;\n}\n\npublic void setNames(List&lt;String&gt; names) {\nthis.names = names;\n}\n\npublic int getNamesCount() {\nList&lt;String&gt; l = getNames();\nreturn (l == null ? 0 : l.size());\n}\n\npublic void setNamesCount(int count) {\nif ( count &lt; 0 ) {\ncount = 0;\n}\nList&lt;String&gt; l = getNames();\nint lCount = (l == null ? 0 : l.size());\nwhile ( lCount &gt; count ) {\nl.remove(l.size() - 1);\nlCount--;\n}\nif ( l == null &amp;&amp; count &gt; 0 ) {\nl = new ArrayList&lt;&gt;();\nsetNames(l);\n}\nwhile ( lCount &lt; count ) {\nl.add(\"\");\nlCount++;\n}\n}\n</code></pre> <p>The <code>SettingUtils.dynamicListSettingSpecifier()</code> method simplifies the creation of a <code>GroupSettingSpecifier</code> that represents a dynamic list (the examples in the following sections demonstrate this).</p>"},{"location":"developers/settings/specifier/#simple-dynamic-list","title":"Simple Dynamic List","text":"<p>A simple Dynamic List is a dynamic list of string or number values.</p> <p></p> <pre><code>private String[] names = new String[0];\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;();\n\n// turn a list of strings into a Group of TextField settings\nGroupSettingSpecifier namesList = SettingUtils.dynamicListSettingSpecifier(\n\"names\", asList(names), (String value, int index, String key) -&gt;\nsingletonList(new BasicTextFieldSettingSpecifier(key, null)));\nresults.add(namesList);\n\nreturn results;\n}\n</code></pre>"},{"location":"developers/settings/specifier/#complex-dynamic-list","title":"Complex Dynamic List","text":"<p>A complex Dynamic List is a dynamic list of arbitrary object values. The main difference in terms of the necessary settings structure required, compared to a Simple Dynamic List, is that a group-of-groups is used.</p> <p></p> Complex data classDynamic List setting <pre><code>public class Person {\nprivate String firstName;\nprivate String lastName;\n\n// generate list of settings for a Person, nested under some prefix\npublic List&lt;SettingSpecifier&gt; settings(String prefix) {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;(2);\nresults.add(new BasicTextFieldSettingSpecifier(prefix + \"firstName\", null));\nresults.add(new BasicTextFieldSettingSpecifier(prefix + \"lastName\", null));\nreturn results;\n}\n\npublic void setFirstName(String firstName) {\nthis.firstName = firstName;\n}\n\npublic void setLastName(String lastName) {\nthis.lastName = lastName;\n}\n}\n</code></pre> <pre><code>private Person[] people = new Person[0];\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;();\n\n// turn a list of People into a Group of Group settings\nGroupSettingSpecifier peopleList = SettingUtils.dynamicListSettingSpecifier(\n\"people\", asList(people), (Person value, int index, String key) -&gt;\nsingletonList(new BasicGroupSettingSpecifier(\nvalue.settings(key + \".\"))));\nresults.add(peopleList);\n\nreturn results;\n}\n</code></pre>"},{"location":"users/","title":"User Guide","text":"<p>This section of the handbook is geared towards users who will be deploying and managing one or more SolarNode devices.</p> <p>See the Getting Started page to jump in!</p>"},{"location":"users/configuration/","title":"Configuration","text":"<p>Some SolarNode components can be configured from properties files. This type of configuration is meant to be changed just once, when a SolarNode is first deployed, to alter some default configuration value. The properties files are read from the <code>/etc/solarnode/services</code> directory and named like <code>NAMESPACE.cfg</code> , where <code>NAMESPACE</code> represents a configuration namespace.</p> <p>Configuration location</p> <p>The <code>/etc/solarnode/services</code> location is the default location in SolarNodeOS. It might be another location in other SolarNode deployments.</p>"},{"location":"users/configuration/#example","title":"Example","text":"<p>Imagine a component uses the configuration namespace <code>com.example.service</code> and supports a configurable property named <code>max-threads</code> that accepts an integer value you would like to configure as <code>4</code>. You would create a <code>com.example.service.properties</code> file like:</p> /etc/solarnode/services/com.example.service.cfg<pre><code>max-threads = 4\n</code></pre>"},{"location":"users/getting-started/","title":"Getting Started","text":"<p>This section describes how to get SolarNode running on a device.</p>"},{"location":"users/getting-started/#get-solarnodeos","title":"Get SolarNodeOS","text":"<p>SolarNodeOS is a complete operating system tailor made for SolarNode. You must download the appropriate SolarNodeOS image for the device you want to run SolarNode on and then copy that image to your device media (typically an SD card). You can use a tool like Etcher to help with that.</p> Raspberry PiOrange PiSomething Else <p>The Raspberry Pi is the best supported option for general SolarNode deployments. Models 3 or later, Compute Module 3 or later, and Zero 2 W or later are supported. Use a tool like Etcher or Raspberry Pi Imager to copy the image to an SD card (minimum size is 2 GB, 4 GB recommended).</p> <p> Download SolarNodeOS for Raspberry Pi</p> <p>The Orange Pi models Zero and Zero Plus are supported. Use a tool like Etcher to copy the image to an SD card (minimum size is 1 GB, 4 GB recommended).</p> <p> Download SolarNodeOS for Orange Pi</p> <p>Looking for SolarNodeOS for a device not listed here? Reach out to us through email or Slack to see if we can help!</p>"},{"location":"users/getting-started/#networking-configuration","title":"Networking configuration","text":"<p>SolarNode needs a network connection. If your device has an ethernet port, that is the most reliable way to get started. See the Networking section for more information, including WiFi details.</p>"},{"location":"users/getting-started/#associate-solarnode-with-solarnetwork","title":"Associate SolarNode with SolarNetwork","text":"<p>Every SolarNode must be associated (registered) with a SolarNetwork account. To associate a SolarNode, you must:</p> <ol> <li>Log into SolarNetwork</li> <li>Generate an invitation for a new SolarNode</li> <li>Paste the invitation into the SolarNode setup page and follow the instructions</li> </ol>"},{"location":"users/getting-started/#log-into-solarnetwork","title":"Log into SolarNetwork","text":"<p>If you do not already have a SolarNetwork account, register for one and then log in.</p>"},{"location":"users/getting-started/#create-solarnode-invitation","title":"Create SolarNode invitation","text":"<p>Click on the My Nodes link. You will see an Invite New SolarNode button, like this:</p> <p></p> <p>Click the Invite New SolarNode button, then fill in and submit the form that appears and select your time zone by clicking on the world map:</p> <p></p> <p>The generated SolarNode invitation will appear next.</p> <p></p> <p>Select and copy the entire invitation. You will need to paste that into the SolarNode setup screen in the next section.</p>"},{"location":"users/getting-started/#accept-invitation-on-solarnode","title":"Accept invitation on SolarNode","text":"<p>Open the SolarNode setup app in your browser. The URL to use might be http://solarnode/ or it might be an IP address like <code>http://192.168.1.123</code>. See the Networking section for more information. You will be greeted with an invitation acceptance form into which you can paste the invitation you generated in SolarNetwork. The acceptance process goes through the following steps:</p> <ol> <li>Submit the invitation in the acceptance form</li> <li>Preview the invitation details</li> <li>Confirm the invitation</li> </ol> Acceptance formPreviewConfirmComplete <p>First you submit the invitation in the acceptance form.</p> <p></p> <p>Next you preview the invitation details.</p> <p>Note</p> <p>The expected SolarNetwork Service value shown in this step will be <code>in.solarnetwork.net</code>.</p> <p></p> <p>Finally, confirm the invitation. This step contacts SolarNetwork and completes the association process.</p> <p>Warning</p> <p>Ensure you provide a Certificate Password on this step, so SolarNetwork can generate a security certificate for your SolarNode.</p> <p></p> <p>When these steps are completed, SolarNetwork will have assigned your SolarNode a unique identifier known as your Node ID. A randomly generated SolarNode login password will have been generated; you are given the opportunity to easily change that if you prefer.</p> <p></p>"},{"location":"users/logging/","title":"Logging","text":"<p>TODO</p>"},{"location":"users/networking/","title":"Networking","text":"<p>SolarNode will attempt to automatically configure networking access from a local DHCP server. For many deployments the local network router is the DHCP server. SolarNode will identify itself with the name <code>solarnode</code>, so in many cases you can reach the SolarNode setup app at http://solarnode/.</p>"},{"location":"users/networking/#wifi","title":"WiFi","text":"<p>If your device will use WiFi for network access, you will need to configure the network name and credentials to use. You can do that by creating a <code>wpa_supplicant.conf</code> file on the SolarNodeOS media (typically an SD card). For Raspberry Pi media, you can mount the SD card on your computer and it will mount the appropriate drive for you.</p> <p></p> <p>Once mounted use your favorite text editor to create a <code>wpa_supplicant.conf</code> file with content like this:</p> <pre><code>country=nz\nnetwork={\n    ssid=\"wifi network name here\"\n    psk=\"wifi password here\"\n}\n</code></pre> <p>Change the <code>country=nz</code> to match your own country code.</p>"},{"location":"users/networking/#finding-solarnodes-ip-address","title":"Finding SolarNode's IP address","text":"<p>To find what IP address SolarNode is using, you have a few options:</p>"},{"location":"users/networking/#consult-your-network-router","title":"Consult your network router","text":"<p>Your local network router is very likely to have a record of SolarNode's network connection. Log into the router's management UI and look for a device named <code>solarnode</code>.</p>"},{"location":"users/networking/#connect-a-keyboard-and-screen","title":"Connect a keyboard and screen","text":"<p>If your SolarNode supports connecting a keyboard and screen, you can log into the SolarNode command line console and run <code>ip -br addr</code> to print out a brief summary of the current networking configuration:</p> <pre><code>$ ip -br addr\n\nlo               UNKNOWN        127.0.0.1/8 ::1/128\neth0             UP             192.168.0.254/24 fe80::e65f:1ff:fed1:893c/64\nwlan0            DOWN\n</code></pre> <p>In the previous output, SolarNode has an ethernet device <code>eth0</code> with an IP address <code>192.168.0.254</code> and a WiFi device <code>wlan0</code> that is not connected. You could reach that SolarNode at <code>http://192.168.0.254/</code>.</p> <p>Tip</p> <p>You can get more details by running <code>ip addr</code> (without the <code>-br</code> argument).</p>"},{"location":"users/placeholders/","title":"Placeholders","text":"<p>SolarNode supports placeholders in some setting values, such as datum data source IDs. These allow you to define a set of parameters that can be consistently applied to many settings.</p> <p>For example, imagine you manage many SolarNode devices across different buildings or sites, You'd like to follow a naming convention for your datum data source ID values that include a code for the building the node is deployed in, along the lines of <code>/BUILDING/DEVICE</code>. You could define a placeholder <code>building</code> and then configure the source IDs like <code>/{building}/device</code>. On each node you'd define the <code>building</code> placeholder with a building-specific value, so at runtime the nodes would resolve actual source ID values with those names replacing the <code>{building}</code> placeholder.</p>"},{"location":"users/placeholders/#placeholder-syntax","title":"Placeholder syntax","text":"<p>Placeholders are written using the form <code>{name:default}</code> where <code>name</code> is the placeholder name and <code>default</code> is an optional default value to apply if no placeholder value exists for the given name. If a default value is not needed, omit the <code>colon</code> so the placeholder becomes just <code>{name}</code>.</p> <p>For example, imagine a set of placeholder values like</p> Name Value building OFFICE1 room BREAK <p>Here are some example settings with placeholders with what they would resolve to:</p> Input Resolved value <code>/{building}/meter</code> <code>/OFFICE1/meter</code> <code>/{building}/{room}/temp</code> <code>/OFFICE1/BREAK/temp</code> <code>/{building}/{floor:1}/{room}</code> <code>/OFFICE1/1/BREAK</code>"},{"location":"users/settings/","title":"Settings Files","text":"<p>SolarNode plugins support configurable properties, called settings. The SolarNode setup app allows you to manage settings through simple web forms.</p> <p>Settings can also be exported and imported in a CSV format, and can be applied when SolarNode starts up with Auto Settings CSV files. Here is an example of a settings form in the SolarNode setup app:</p> <p></p> <p>There are 3 settings represented in that screen shot:</p> <ol> <li>Schedule</li> <li>Destination</li> <li>Temporary Destination</li> </ol> <p>Tip</p> <p>Nearly every form field you can edit in the SolarNode setup app represents a setting for a component in SolarNode.</p> <p>In the SolarNode setup app the settings can be imported and exported from the main Settings screen:</p> <p></p>"},{"location":"users/settings/#settings-csv-example","title":"Settings CSV example","text":"<p>Here's an example snippet of a settings CSV file:</p> <pre><code>net.solarnetwork.node.io.modbus.1,serialParams.baudRate,19200,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.1,serialParams.parityString,even,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.1,serialParams.portName,/dev/cuaU0,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.FACTORY,1,1,0,2014-03-01 21:00:31\n</code></pre> <p>These settings all belong to a <code>net.solarnetwork.node.io.modbus</code> component. The meaning of the CSV columns is discussed in the following section.</p>"},{"location":"users/settings/#settings-csv-syntax","title":"Settings CSV syntax","text":"<p>Settings files are CSV (comma separated values) files, easily exported from spreadsheet applications like Microsoft Excel or Google Sheets. The CSV must include a header row, which is skipped. All other rows will be processed as settings.</p> <p>The Settings CSV format uses a quite general format and contains the following columns:</p> # Name Description 1 key A unique identifier for the service the setting applies to. 2 type A unique identifier for the setting with the service specified by <code>key</code>, typically using standard property syntax. 3 value The setting value. 4 flags An integer bitmask of flags associated with the setting. See the flags section for more info. 5 modified The date the setting was last modified, in <code>yyyy-MM-dd HH:mm:ss</code> format. <p>To understand the <code>key</code> and <code>type</code> values required for a given component requires consulting the documentation of the plugin that provides that component. You can get a pretty good picture of what the values are by exporting the settings after configuring a component in SolarNode. Typically the <code>key</code> value will mirror a plugin's Java package name, and <code>type</code> follows a JavaScript-like property accessor syntax representing a configurable property on the component.</p>"},{"location":"users/settings/#setting-property-syntax","title":"Setting property syntax","text":"<p>The <code>type</code> setting value usually defines a component property using a JavaScript-like syntax with these rules:</p> Expression Example Description Property <code>name</code> a property named <code>name</code> Nested property <code>name.subname</code> a nested property <code>subname</code> on a parent property <code>name</code> List property <code>name[0]</code> the first element of an indexed list property named <code>name</code> Map property <code>name['key']</code> the <code>key</code> element of the map property <code>name</code> <p>These rules can be combined into complex expressions, for example <code>propIncludes[0].name</code> or <code>delegate.connectionFactory.propertyFilters['UID']</code>.</p>"},{"location":"users/settings/#setting-flags","title":"Setting flags","text":"<p>Each setting has a set of flags that can be associated with it. The following table outlines the bit offset for each flag along with a description:</p> # Name Description 0 Ignore modification date If this flag is set then changes to the associated setting will not trigger a new auto backup. 1 Volatile If this flag is set then changes to the associated setting will not trigger an internal \"setting changed\" event to be broadcast. <p>Note these are bit offsets, so the decimal value to ignore modification date is <code>1</code>, to mark as volatile is <code>2</code>, and for both is <code>3</code>.</p>"},{"location":"users/settings/#component-factories","title":"Component factories","text":"<p>Many plugins provide component factories which allow you to configure any number of instances of that component. Each component instance is assigned a unique identifier when it is created. In the SolarNode setup app, the component instance identifiers appear throughout the UI:</p> <p></p> <p>In the previous example CSV the Modbus I/O plugin allows you to configure any number of Modbus connection components, each with their own specific settings. That is an example of a component factory. The settings CSV will include a special row to indicate that such a factory component should be activated, using a unique identifier, and then all the settings associated with that factory instance will have that unique identifier appended to its <code>key</code> values.</p> <p>Going back to that example CSV, this is the row that activates a Modbus I/O component instance with an identifier of <code>1</code>:</p> <pre><code>net.solarnetwork.node.io.modbus.FACTORY,1,1,0,2014-03-01 21:00:31\n</code></pre> <p>The synax for <code>key</code> column is simply the service identifier followed by <code>.FACTORY</code>. Then the <code>type</code> and <code>value</code> columns are both set the same unique identifier. In this example that identifier is <code>1</code>. For all settings specific to a factory component, the <code>key</code> column will be the service identifier followed by <code>.IDENTIFIER</code> where <code>IDENTIFIER</code> is the unique instance identifier.</p> <p>Here is an example that shows two factory instances configured: <code>Lighting</code> and <code>HVAC</code>. Each have a different <code>serialParams.portName</code> setting value configured:</p> <pre><code>net.solarnetwork.node.io.modbus.Lighting,serialParams.portName,/dev/cuaU0,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.HVAC,serialParams.portName,/dev/ttyUSB0,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.FACTORY,Lighting,Lighting,0,2014-03-01 21:00:31\nnet.solarnetwork.node.io.modbus.FACTORY,HVAC,HVAC,0,2014-03-01 21:00:31\n</code></pre>"},{"location":"users/settings/#auto-settings","title":"Auto settings","text":"<p>SolarNode settings can also be configured through Auto Settings, applied when SolarNode starts up, by placing Settings CSV files in the <code>/etc/solarnode/auto-settings.d</code> directory. These settings are applied only if they don't already exist or the modified date in the settings file is newer than the date they were previously applied.</p>"}]}