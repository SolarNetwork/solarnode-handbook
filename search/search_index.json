{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SolarNode Handbook","text":"<p>This handbook provides guides and reference documentation about SolarNode, the distributed component of SolarNetwork.</p>"},{"location":"#user-guide","title":"User Guide","text":"<p>For information on getting and using SolarNode, see the User Guide.</p>"},{"location":"#developer-guide","title":"Developer Guide","text":"<p>For information on working on the SolarNode codebase, such as writing a plugin, see the Developer Guide.</p>"},{"location":"developers/","title":"Developer Guide","text":"<p>TODO</p>"},{"location":"developers/osgi/","title":"Plugins","text":"<p>The SolarNode platform has been designed to be highly modular and dynamic, by using a plugin-based architecture. The plugin system SolarNode uses is based on the OSGi specification, where plugins are implemented as OSGi bundles. SolarNode can be thought of as a collection of OSGi bundles that, when combined and deployed together in an OSGi framework like Eclipse Equinox, form the complete SolarNode platform.</p> <p>To summarize: everything in SolarNode is a plugin!</p> <p>OSGi bundles and Eclipse plug-ins</p> <p>Each OSGi bundle in SolarNode comes configured as an Eclipse IDE (or simply Eclipse) plug-in project. Eclipse refers to OSGi bundles as \"plug-ins\" and its OSGi development tools are collectively known as the Plug-in Development Environment, or PDE for short. We use the terms bundle and plug-in and plugin somewhat interchangably in the SolarNode project. Although Eclipse is not actually required for SolarNode development, it is very convenient.</p> <p>Practically speaking a plugin, which is an OSGi bundle, is simply a Java JAR file that includes the Java code implementing your plugin and some OSGi metadata in its Manifest.</p>"},{"location":"developers/osgi/#services","title":"Services","text":"<p>Central to the plugin architecture SolarNode uses is the concept of a service. In SolarNode a service is defined by a Java interface. A plugin can advertise a service to the SolarNode runtime. Plugins can lookup a service in the SolarNode runtime and then invoke the methods defined on it.</p> <p>The advertising/lookup framework SolarNode uses is provided by OSGi. OSGi provides several ways to manage services. In SolarNode the most common is to use Blueprint XML documents to both publish services (advertise) and acquire references to services (lookup).</p>"},{"location":"developers/osgi/blueprint/","title":"Blueprint","text":"<p>SolarNode supports the OSGi Blueprint Container Specification so plugins can declare their service dependencies and register their services by way of an XML file deployed with the plugin. If you are familiar with the Spring Framework's XML configuration, you will find Blueprint very similar. SolarNode uses the Eclipse Gemini implementation of the Blueprint specification, which is directly derived from Spring Framework.</p> <p>Note</p> <p>This guide will not document the full Blueprint XML syntax. Rather, it will attempt to showcase the most common parts used in SolarNode. Refer to the Blueprint Container Specification for full details of the specification.</p>"},{"location":"developers/osgi/blueprint/#example","title":"Example","text":"<p>Imagine you are working on a plugin and have a <code>com.example.Greeter</code> interface you would like to register as a service for other plugins to use, and an implementation of that service in  <code>com.example.HelloGreeter</code> that relies on the Placeholder  Service provided by SolarNode:</p> Greeter serviceHelloGreeter implementation <pre><code>package com.example;\npublic interface Greeter {\n\n/**\n     * Greet something with a given name.\n     * @param name the name to greet\n     * @return the greeting\n     */\nString greet(String name);\n\n}\n</code></pre> <pre><code>package com.example;\nimport net.solarnetwork.node.service.PlaceholderService;\npublic class HelloGreeter implements Greeter {\n\nprivate final PlaceholderService placeholderService;\n\npublic HelloGreeter(PlaceholderService placeholderService) {\nsuper();\nthis.placeholderService = placeholderService;\n}\n\n@Override\npublic String greet(String name) {\nreturn placeholderService.resolvePlaceholders(\nString.format(\"Hello %s, from {myName}.\", name),\nnull);\n}\n}\n</code></pre> <p>Assuming the <code>PlaceholderService</code> will resolve <code>{name}</code> to <code>Office Node</code>, we would expect the <code>greet()</code> method to run like this:</p> <pre><code>Greeter greeter = resolveGreeterService();\nString result = greeter.greet(\"Joe\");\n// result is \"Hello Joe, from Office Node.\"\n</code></pre> <p>In the plugin we then need to:</p> <ol> <li>Obtain a <code>net.solarnetwork.node.service.PlaceholderService</code> to pass to the     <code>HelloGreeter(PlaceholderService)</code> constructor</li> <li>Register  the <code>HelloGreeter</code> comopnent as a <code>com.example.Greeter</code> service in the SolarNode     platform</li> </ol> <p>Here is an example Blueprint XML document that does both:</p> Blueprint XML example<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\"&gt;\n\n&lt;!-- Declare a reference (lookup) to the PlaceholderService --&gt;\n&lt;reference id=\"placeholderService\"\ninterface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n\n&lt;service interface=\"com.example.Greeter\"&gt;\n&lt;bean class=\"com.example.HelloGreeter\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;/bean&gt;\n&lt;/service&gt;\n\n&lt;/blueprint&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#blueprint-xml-resources","title":"Blueprint XML Resources","text":"<p>Blueprint XML documents are added to a plugin's <code>OSGI-INF/blueprint</code> classpath location. A plugin can provide any number of Blueprint XML documents there, but often a single file is sufficient and a common convention in SolarNode is to name it <code>module.xml</code>.</p>"},{"location":"developers/osgi/blueprint/#xml-syntax","title":"XML Syntax","text":"<p>A minimal Blueprint XML file is structured like this:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\"&gt;\n\n&lt;!-- Plugin components configured here --&gt;\n\n&lt;/blueprint&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#service-references","title":"Service References","text":"<p>To make use of services registered by SolarNode plugins, you declare a reference to that service so you may refer to it elsewhere within the Blueprint XML. For example, imagine you wanted to use the Placeholder Service in your component. You would obtain a reference to that like this:</p> <pre><code>&lt;reference id=\"placeholderService\"\ninterface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n</code></pre> <p>The <code>id</code> attribute allows you to refer to this service elsewhere in your Blueprint XML, while <code>interface</code> declares the fully-qualified Java interface of the service you want to use.</p>"},{"location":"developers/osgi/blueprint/#components","title":"Components","text":"<p>Components in Blueprint are Java classes you would like instantiated when your plugin starts. They are declared using a <code>&lt;bean&gt;</code> element in Blueprint XML. You can assign each component a unique identifier using an <code>id</code> attribute, and then you can refer to that component in other components.</p> <p>Imagine an example component class <code>com.example.MyComponent</code>:</p> <pre><code>package com.example;\n\nimport net.solarnetwork.node.service.PlaceholderService;\n\npublic class MyComponent {\n\nprivate final PlaceholderService placeholderService;\nprivate int minimum;\n\npublic MyComponent(PlaceholderService placeholderService) {\nsuper();\nthis.placeholderService = placeholderService;\n}\n\npublic String go() {\nreturn PlaceholderService.resolvePlaceholders(placeholderService,\n\"{building}/temp\", null);\n}\n\npublic int getMinimum() {\nreturn minimum;\n}\n\npublic void setMinimum(int minimum) {\nthis.minimum = minimum;\n}\n}\n</code></pre> <p>Here is how that component could be declared in Blueprint:</p> <pre><code>&lt;reference id=\"placeholderService\"\ninterface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n\n&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;property name=\"minimum\" value=\"10\"/&gt;\n&lt;/bean&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#constructor-arguments","title":"Constructor Arguments","text":"<p>If your component requires any constructor arguments, they can be specified with nested <code>&lt;argument&gt;</code> elements in Blueprint. The <code>&lt;argument&gt;</code> value can be specified as a reference to another component using a <code>ref</code> attribute whose value is the <code>id</code> of that component, or as a literal value using a <code>value</code> attribute.</p> <p>For example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;argument value=\"10\"&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#property-accessors","title":"Property Accessors","text":"<p>You can configure mutable class properties on a component with nested <code>&lt;property name=\"\"&gt;</code> elements in Blueprint. A mutable property is a Java setter method. For example an <code>int</code> property <code>minimum</code> would be associated with a Java setter method <code>public void setMinimum(int value)</code>.</p> <p>The <code>&lt;property&gt;</code> value can be specified as a reference to another component using a <code>ref</code> attribute whose value is the <code>id</code> of that component, or as a literal value using a <code>value</code> attribute.</p> <p>For example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;property name=\"placeholderService\" ref=\"placeholderService\"&gt;\n&lt;argument name=\"minimum\" value=\"10\"&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#startstop-hooks","title":"Start/Stop Hooks","text":"<p>Blueprint can invoke a method on your component when it has finished instantiating and configuring the object (when the plugin starts), and another when it destroys the instance (when the plugin is stopped). You simply provide the name of the method you would like Blueprint to call in the <code>init-method</code> and <code>destroy-method</code> attributes of the <code>&lt;bean&gt;</code> element. For example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"\ninit-method=\"startup\"\ndestroy-method=\"shutdown\"&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#service-registration","title":"Service Registration","text":"<p>You can make any component available to other plugins by registering the component with a <code>&lt;service&gt;</code> element that declares what interface(s) your component provides. Once registered, other plugins can make use of your component, for example by declaring a <code>&lt;referenece&gt;</code> to your component class in their Blueprint XML.</p> <p>Note</p> <p>You can only register Java interfaces as services, not classes.</p> <p>For example, imagine a <code>com.example.Startable</code> interface like this:</p> <pre><code>package com.example;\npublic interface Startable {\n/**\n     * Start!\n     * @return the result\n     */\nString go();\n}\n</code></pre> <p>We could implement that interface in the <code>MyComponent</code> class, like this:</p> <pre><code>package com.example;\n\npublic class MyComponent implements Startable {\n\n@Override\npublic String go() {\nreturn \"Gone!\";\n}\n}\n</code></pre> <p>We can register <code>MyComponent</code> as a <code>Startable</code> service using a <code>&lt;service&gt;</code> element like this in Blueprint:</p> Direct service componentIndirect service component <pre><code>&lt;service interface=\"com.example.Startable\"&gt;\n&lt;!-- The service implementation is nested directly within --&gt;\n&lt;bean class=\"com.example.MyComponent\"/&gt;\n&lt;/service&gt;\n</code></pre> <pre><code>&lt;!-- The service implementation is referenced indirectly... --&gt;\n&lt;service ref=\"myComponent\" interface=\"com.example.Startable\"/&gt;\n\n&lt;!-- ... to a bean with a matching id attribute --&gt;\n&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"/&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#multiple-service-interfaces","title":"Multiple Service Interfaces","text":"<p>You can advertise any number of service interfaces that your component supports, by nesting an <code>&lt;interfaces&gt;</code> element within the <code>&lt;service&gt;</code> element, in place of the <code>interface</code> attribute. For example:</p> <pre><code>&lt;service ref=\"myComponent\"&gt;\n&lt;interfaces&gt;\n&lt;value&gt;com.example.Startable&lt;/value&gt;\n&lt;value&gt;com.example.Stopable&lt;/value&gt;\n&lt;/interfaces&gt;\n&lt;/service&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#export-service-packages","title":"Export service packages","text":"<p>For a registered service to be of any use to another plugin, the package the service is defined in must be exported by the plugin hosting that package. That is because the plugin wishing to add a reference to the service will need to import the package in order to use it.</p> <p>For example, the plugin that hosts the <code>com.example.service.MyService</code> service would need a manifest file that includes an <code>Export-Package</code> attribute similar to:</p> <pre><code>Export-Package: com.example.service;version=\"1.0.0\"\n</code></pre>"},{"location":"developers/osgi/manifest/","title":"Manifest","text":"<p>As SolarNode plugins are OSGi bundles, which are Java JAR files, every plugin automatically includes a <code>META-INF/MANIFEST.MF</code> file as defined in the Java JAR File Specification. The <code>MANIFEST.MF</code> file is where OSGi metadata is included, turning the JAR into an OSGi bundle (plugin).</p>"},{"location":"developers/osgi/manifest/#example","title":"Example","text":"<p>Here is an example snippet from the SolarNode net.solarnetwork.common.jdt plugin:</p> Example plugin MANIFEST.MF<pre><code>Manifest-Version: 1.0\nBundle-ManifestVersion: 2\nBundle-Name: Java Compiler Service (JDT)\nBundle-SymbolicName: net.solarnetwork.common.jdt\nBundle-Description: Java complier using Eclipse JDT.\nBundle-Version: 3.0.0\nBundle-Vendor: SolarNetwork\nBundle-RequiredExecutionEnvironment: JavaSE-1.8\nBundle-Activator: net.solarnetwork.common.jdt.Activator\nExport-Package:\nnet.solarnetwork.common.jdt;version=\"2.0.0\"\nImport-Package:\nnet.solarnetwork.service;version=\"[1.0,2.0)\",\norg.eclipse.jdt.core.compiler,\norg.eclipse.jdt.internal.compiler,\norg.osgi.framework;version=\"[1.5,2.0)\",\norg.slf4j;version=\"[1.7,2.0)\",\norg.springframework.context;version=\"[5.3,6.0)\",\norg.springframework.core.io;version=\"[5.3,6.0)\",\norg.springframework.util;version=\"[5.3,6.0)\"\n</code></pre> <p>The rest of this document will describe this structure in more detail.</p>"},{"location":"developers/osgi/manifest/#versioning","title":"Versioning","text":"<p>In OSGi plugins are always versioned and and Java packages may be versioned. Versions follow Semantic Versioning rules, generally using this syntax:</p> <pre><code>major.minor.patch\n</code></pre> <p>In the manifest example you can see the plugin version <code>3.0.0</code> declared in the <code>Bundle-Version</code> attribute:</p> <pre><code>Bundle-Version: 3.0.0\n</code></pre> <p>The example also declares (exports) a <code>net.solarnetwork.common.jdt</code> package for other plugins to import (use) as version <code>2.0.0</code>, in the <code>Export-Package</code> attribute:</p> <pre><code>Export-Package:\nnet.solarnetwork.common.jdt;version=\"2.0.0\"\n</code></pre> <p>The example also uses (imports) a versioned package <code>net.solarnetwork.service</code> using a version range greater than or equal to <code>1.0</code> and less than <code>2.0</code> and an unversioned package <code>org.eclipse.jdt.core.compiler</code>, in the <code>Import-Package</code> attribute:</p> <pre><code>Import-Package:\nnet.solarnetwork.service;version=\"[1.0,2.0)\",\norg.eclipse.jdt.core.compiler,\n</code></pre> <p>Tip</p> <p>Some plugins, and core Java system packages, do not declare package versions. You should declare package versions in your own plugins.</p>"},{"location":"developers/osgi/manifest/#version-ranges","title":"Version ranges","text":"<p>Some OSGi version attributes allow version ranges to be declared, such as the <code>Import-Package</code> attribute. A version range is a comma-delimited <code>lower,upper</code> specifier. Square brackets are used to represent inclusive  values and round brackets represent exclusive values. A value can be omitted to reprsent an unbounded value. Here are some examples:</p> Range Logic Description <code>[1.0,2.0)</code> 1.0.0 \u2264 x &lt; 2.0.0 Greater than or equal to <code>1.0.0</code> and less than <code>2.0.0</code> <code>(1,3)</code> 1.0.0 &lt; x &lt; 3.0.0 Greater than <code>1.0.0</code> and less than <code>3.0.0</code> <code>[1.3.2,)</code> 1.3.2 \u2264 x Greater than or eequal to <code>1.3.2</code> <code>1.3.2</code> 1.3.2 \u2264 x Greater than or eequal to <code>1.3.2</code> (shorthand notation) <p>Implied unbounded range</p> <p>An inclusive lower, unbounded upper range can be specifeid using a shorthand notation of just the lower bound, like <code>1.3.2</code>.</p>"},{"location":"developers/osgi/manifest/#required-attributes","title":"Required attributes","text":"<p>Each plugin must provide the following attributes:</p> Attribute Example Description <code>Bundle-ManifestVersion</code> 2 declares the OSGi bundle manifest version; always <code>2</code> <code>Bundle-Name</code> Awesome Data Source a concise human-readable name for the plugin <code>Bundle-SymbolicName</code> com.example.awesome a machine-readable, universally unique identifier for the plugin <code>Bundle-Version</code> 1.0.0 the plugin version <code>Bundle-RequiredExecutionEnvironment</code> JavaSE-1.8 a required OSGi execution environment"},{"location":"developers/osgi/manifest/#recommended-attributes","title":"Recommended attributes","text":"<p>Each plugin is recommended to provide the following attributes:</p> Attribute Example Description <code>Bundle-Description</code> An awesome data source that collects awesome data. a longer human-readable description of the plugin <code>Bundle-Vendor</code> ACME Corp the name of the entity or organisation that authored the plugin"},{"location":"developers/osgi/manifest/#common-attributes","title":"Common attributes","text":"<p>Other common manifest attributes are:</p> Attribute Example Description <code>Bundle-Activator</code> com.example.awesome.Activator a fully-qualified Java class name that implements the <code>org.osgi.framework.BundleActivator</code> interface, to handle plugin lifecycle events <code>Export-Package</code> net.solarnetwork.common.jdt;version=\"2.0.0\" a package export list <code>Import-Package</code> net.solarnetwork.service;version=\"[1.0,2.0)\" a package dependency list"},{"location":"developers/osgi/manifest/#package-dependencies","title":"Package dependencies","text":"<p>A plugin must declare the Java packages it directly uses in a <code>Import-Package</code> attribute. This attribute accpets a comma-delimited list of package specifications that take the basic form of:</p> <pre><code>PACKAGE;version=\"VERSION\"\n</code></pre> <p>For example here is how the <code>net.solarnetwork.service</code> package, versioned between <code>1.0</code> and <code>2.0</code>, would be declared:</p> <pre><code>Import-Package: net.solarnetwork.service;version=\"[1.0,2.0)\"\n</code></pre> <p>Direct package use means your plugin has code that imports a class from a given package. Classes in an imported package may import other packages indirectly; you do not need to import those packages as well.  For example if you have code like this:</p> <pre><code>import net.solarnetwork.service.OptionalService;\n</code></pre> <p>Then you will need to import the <code>net.solarnetwork.service</code> package.</p> <p>Note</p> <p>The SolarNode platform automatically imports core Java packages like <code>java.*</code> so you do not need to declare those.</p> <p>Also note that in some scenarios a package used by a class in an imported package becomes a direct dependency. For example when you extend a class from an imported package and that class imports other packages. Those other packages may become direct dependencies that you also need to import.</p>"},{"location":"developers/osgi/manifest/#child-package-dependencies","title":"Child package dependencies","text":"<p>If you import a package in your plugin, any child packages that may exist are not imported as well. You must import every individual package you need to use in your plugin.</p> <p>For example to use both <code>net.solarnetwork.service</code> and <code>net.solarnetwork.service.support</code> you would have an <code>Import-Package</code> attribute like this:</p> <pre><code>Import-Package:\nnet.solarnetwork.service;version=\"[1.0,2.0)\",\nnet.solarnetwork.service.support;version=\"[1.1,2.0)\"\n</code></pre>"},{"location":"developers/osgi/manifest/#package-exports","title":"Package exports","text":"<p>A plugin can export any package it provides, making the resources within that package available to other plugins to import and use. Declare exoprted packages with a <code>Export-Package</code> attribute. This attribute takes a comma-delimited list of versioned package specifications. Note that version ranges are not supported: you must declare the exact version of the package you are exporting. For example:</p> <pre><code>Export-Package: com.example.service;version=\"1.0.0\"\n</code></pre> <p>Note</p> <p>Exported packages should not be confused with services. Exported packages give other plugins access to the classes and any other resources within those packages, but do not provide services to the platform. You can use Blueprint to register services. Keep in mind that any service a plugin registers must exist within an exported package to be of any use.</p>"},{"location":"developers/services/closeable-service/","title":"Closeable Service","text":"<p>A plugin can publish a <code>net.solarnetwork.service.CloseableService</code> and SolarNode will invoke the <code>closeService()</code> method on it when that service is destroyed. This can be useful in some situations, to make sure resources are freed when a service is no longer needed.</p> <p>Blueprint does provide the <code>destroy-method</code> stop hook that can be used in many situations, however Blueprint does not allow this in all cases. For example a <code>&lt;bean&gt;</code> nested within a <code>&lt;service&gt;</code> element does not allow a <code>destroy-method</code>:</p> <pre><code>&lt;service interface=\"com.example.MyService\"&gt;\n&lt;!-- destroy-method not allowed here: --&gt;\n&lt;bean class=\"com.example.MyComponent\"/&gt;\n&lt;/service&gt;\n</code></pre> <p>If <code>MyComponent</code> also implemented <code>CloseableService</code> then we can achieve the desired stop hook like this:</p> <pre><code>&lt;service&gt;\n&lt;interfaces&gt;\n&lt;value&gt;com.example.MyService&lt;/value&gt;\n&lt;value&gt;net.solarnetwork.service.CloseableService&lt;/value&gt;\n&lt;/interfaces&gt;\n&lt;bean class=\"com.example.MyComponent\"/&gt;\n&lt;/service&gt;\n</code></pre> <p>Note</p> <p>Note that the above example <code>CloseableService</code> is not strictly needed, as the same effect could be acheived by un-nesting the <code>&lt;bean&gt;</code> from the <code>&lt;service&gt;</code> element, like this:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\" destroy-method=\"close\"/&gt;\n&lt;service ref=\"myComponent\" interface=\"com.example.MyService\"/&gt;\n</code></pre> <p>There are situations where un-nesting is not possible, which is where <code>CloseableService</code> can be helpful.</p>"},{"location":"developers/services/job-scheduler/","title":"Job Scheduler","text":"<p>SolarNode provides a Job Scheduler service that can automatically schedule and execute jobs exported by plugins.</p>"},{"location":"developers/services/job-scheduler/#configuration","title":"Configuration","text":"<p>The Job Scheduler supports the following configuration properties in the <code>net.solarnetwork.node.core</code> namespace:</p> Property Default Description <code>jobScheduler.poolSize</code> 10 The number of threads to maintain in the job scheduler, and thus the maximum number of jobs that can run simultaneously. Must be set to 1 or higher. <code>scheduler.startupDelay</code> 180 A delay in seconds after creating the job scheduler to start triggering jobs. This can be useful to give the application time to completely initialize before starting to run jobs."},{"location":"developers/services/placeholder-service/","title":"Placeholder Service","text":"<p>The Placeholder Service API provides components a way to resolve variables in strings, known as placeholders, whose values are managed outside the component itself. For example a datum data source plugin could use the Placeholder Service to support resolving placeholders in a configurable Source ID property.</p> <p>SolarNode provides a Placeholder Service implementation that resolves both dynamic placeholders from the Settings Database (using the setting namespace <code>placeholder</code>), and static placeholders from a configurable file or directory location.</p>"},{"location":"developers/services/placeholder-service/#use","title":"Use","text":"<p>Call the <code>resolvePlaceholders(s, parameters)</code> method to resolve all placeholders on the String <code>s</code>. The <code>parameters</code> argument can be used to provide additional placeholder values, or you can pass just pass <code>null</code> to rely solely on the placeholders available in the service already.</p>"},{"location":"developers/services/placeholder-service/#example","title":"Example","text":"<p>Here is an imaginary class that is constructed with an optional <code>PlaceholderService</code>, and then when the <code>go()</code> method is called uses that to resolve placeholders in the string <code>{building}/temp</code> and return the result:</p> <pre><code>package com.example;\n\nimport net.solarnetwork.node.service.PlaceholderService;\nimport net.solarnetwork.service.OptionalService;\n\npublic class MyComponent {\n\nprivate final OptionalService&lt;PlaceholderService&gt; placeholderService;\n\npublic MyComponent(OptionalService&lt;PlaceholderService&gt; placeholderService) {\nsuper();\nthis.placeholderService = placeholderService;\n}\n\npublic String go() {\nreturn PlaceholderService.resolvePlaceholders(placeholderService,\n\"{building}/temp\", null);\n}\n}\n</code></pre>"},{"location":"developers/services/placeholder-service/#blueprint","title":"Blueprint","text":"<p>To use the Placeholder Service in your component, add either an Optional Service or explicit reference to your plugin's Blueprint XML file like this (depending on what your plugin requires):</p> Optional ServiceExplicit Reference <pre><code>&lt;bean id=\"placeholderService\" class=\"net.solarnetwork.common.osgi.service.DynamicServiceTracker\"&gt;\n&lt;argument ref=\"bundleContext\"/&gt;\n&lt;property name=\"serviceClassName\" value=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n&lt;property name=\"sticky\" value=\"true\"/&gt;\n&lt;/bean&gt;\n</code></pre> <pre><code>&lt;reference id=\"placeholderService\" interface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n</code></pre> <p>Then inject that service into your component's <code>&lt;bean&gt;</code>, for example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;/bean&gt;\n</code></pre>"},{"location":"developers/services/placeholder-service/#configuration","title":"Configuration","text":"<p>The Placeholder Service supports the following configuration properties in the <code>net.solarnetwork.node.core</code> namespace:</p> Property Default Description <code>placeholders.dir</code> ${CONF_DIR}/placeholders.d Path to a single propertites file or to a directory of properties files to load as static placeholder parameter values when SolarNode starts up."},{"location":"developers/services/settings-db/","title":"Settings Database","text":"<p>TODO</p>"},{"location":"developers/services/settings-service/","title":"Settings Service","text":"<p>TODO</p>"},{"location":"developers/settings/","title":"Settings","text":"<p>SolarNode provides a way for plugin components to describe their user-configurable properties, called settings, to the platform. SolarNode provides a web-based GUI that makes it easy for users to configure those components using a web browser. For example, here is a screen shot of the SolarNode GUI showing a form for the settings of a Database Backup component:</p> <p></p> <p>The mechanism for components to describe themselves in this way is called the Settings API. Classes that wish to participate in this system publish metadata about their configurable properties, and then SolarNode displays a GUI based on that metadata. The process is similar to the built-in Settings app on iOS: iOS applications can publish configurable property definitions and the Settings app displays a GUI that allows users to modify those properties.</p>"},{"location":"developers/settings/factory/","title":"Factory Service","text":""},{"location":"developers/settings/provider/","title":"Settings Provider","text":"<p>The <code>net.solarnetwork.settings.SettingSpecifierProvider</code> interface defines the way a class can declare themselves as a configurable component. The main elements of this API are:</p> <pre><code>public interface SettingSpecifierProvider {\n\n/**\n     * Get a unique, application-wide setting ID.\n     *\n     * @return unique ID\n     */\nString getSettingUid();\n\n/**\n     * Get a non-localized display name.\n     *\n     * @return non-localized display name\n     */\nString getDisplayName();\n\n/**\n     * Get a list of {@link SettingSpecifier} instances.\n     *\n     * @return list of {@link SettingSpecifier}\n     */\nList&lt;SettingSpecifier&gt; getSettingSpecifiers();\n\n}\n</code></pre> <p>The <code>getSettingUid()</code> method defines a unique ID for the configurable component. By convention the class or package name of the component (or a derivative of it) is used as the ID.</p> <p>The <code>getSettingSpecifiers()</code> method returns a list of all the configurable properties of the component, as a list of <code>SettingSpecifier</code> instances.</p>"},{"location":"developers/settings/resource-handler/","title":"Setting Resource Handler","text":"<p>The <code>net.solarnetwork.node.settings.SettingResourceHandler</code> API defines a way for a component to import and export files uploaded to SolarNode from external sources.</p> <p>A component could support importing a file using the File setting. This could be used, to provide a way of configuring the component from a configuration file, like CSV, JSON, XML, and so on. Similarly a component could support exporting a file, to generate a configuration file in another format like CSV, JSON, XML, and so on, from its current settings. For example, the Modbus Device Datum Source does exactly these things: importing and exporting a custom CSV file to make configuring the component easier.</p>"},{"location":"developers/settings/resource-handler/#importing","title":"Importing","text":"<p>The main part of the <code>SettingResourceHandler</code> API for importing files looks like this:</p> <pre><code>public interface SettingResourceHandler {\n\n/**\n     * Get a unique, application-wide setting ID.\n     *\n     * &lt;p&gt;\n     * This ID must be unique across all setting resource handlers registered\n     * within the system. Generally the implementation will also be a\n     * {@link net.solarnetwork.settings.SettingSpecifierProvider} for the same\n     * ID.\n     * &lt;/p&gt;\n     *\n     * @return unique ID\n     */\nString getSettingUid();\n\n/**\n     * Apply settings for a specific key from a resource.\n     *\n     * @param settingKey\n     *        the setting key, generally a\n     *        {@link net.solarnetwork.settings.KeyedSettingSpecifier#getKey()}\n     *        value\n     * @param resources\n     *        the resources with the settings to apply\n     * @return any setting values that should be persisted as a result of\n     *         applying the given resources (never {@literal null}\n     * @throws IOException\n     *         if any IO error occurs\n     */\nSettingsUpdates applySettingResources(String settingKey, Iterable&lt;Resource&gt; resources)\nthrows IOException;\n</code></pre> <p>The <code>getSettingUid()</code> method overlaps with the Settings Provider API, and as the comments note it is typical for a Settings Provider that publishes settings like File or Text Area to also implement <code>SettingResourceHandler</code>.</p> <p>The <code>settingKey</code> passed to the <code>applySettingResources()</code> method identifies the resource(s) being uploaded, as a single Setting Resource Handler might support multiple resources. For example a Settings Provider might publish multiple File settings, or File and Text Area settings. The <code>settingKey</code> is used to differentiate between each one.</p>"},{"location":"developers/settings/resource-handler/#importing-example","title":"Importing example","text":"<p>Imagine a component that publishes a File setting. A typical implementation of that component would look like this (this example omits some methods for brevity):</p> <pre><code>public class MyComponent implements SettingSpecifierProvider,\nSettingResourceHandler {\n\nprivate static final Logger log\n= LoggerFactory.getLogger(MyComponent.class);\n\n/** The resource key to identify the File setting resource. */\npublic static final String RESOURCE_KEY_DOCUMENT = \"document\";\n\n@Override\npublic String getSettingUid() {\nreturn \"com.example.mycomponent\";\n}\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;();\n\n// publish a File setting tied to the RESOURCE_KEY_DOCUMENT key,\n// allowing only text files to be accepted\nresults.add(new BasicFileSettingSpecifier(RESOURCE_KEY_DOCUMENT, null,\nnew LinkedHashSet&lt;&gt;(asList(\".txt\", \"text/*\")), false));\n\nreturn results;\n}\n\n@Override\npublic SettingsUpdates applySettingResources(String settingKey,\nIterable&lt;Resource&gt; resources) throws IOException {\nif ( resources == null ) {\nreturn null;\n}\nif ( RESOURCE_KEY_DOCUMENT.equals(settingKey) ) {\nfor ( Resource r : resources ) {\n// here we would do something useful with the resource... like\n// read into a string and log it\nString s = FileCopyUtils.copyToString(new InputStreamReader(\nr.getInputStream(), StandardCharsets.UTF_8));\n\nlog.info(\"Got {} resource content: {}\", settingKey, s);\n\nbreak; // only accept one file\n}\n}\nreturn null;\n}\n\n}\n</code></pre>"},{"location":"developers/settings/resource-handler/#exporting","title":"Exporting","text":"<p>The part of the Setting Resource Handler API that supports exporting setting resources looks like this:</p> <pre><code>    /**\n     * Get a list of supported setting keys for the\n     * {@link #currentSettingResources(String)} method.\n     *\n     * @return the set of supported keys\n     */\ndefault Collection&lt;String&gt; supportedCurrentResourceSettingKeys() {\nreturn Collections.emptyList();\n}\n\n/**\n     * Get the current setting resources for a specific key.\n     *\n     * @param settingKey\n     *        the setting key, generally a\n     *        {@link net.solarnetwork.settings.KeyedSettingSpecifier#getKey()}\n     *        value\n     * @return the resources, never {@literal null}\n     */\nIterable&lt;Resource&gt; currentSettingResources(String settingKey);\n</code></pre> <p>The <code>supportedCurrentResourceSettingKeys()</code> method returns a set of resource keys the component supports for exporting. The <code>currentSettingResources()</code> method returns the resources to export for a given key.</p> <p>The SolarNode GUI shows a form menu with all the available resources for all components that support the <code>SettingResourceHandler</code> API, and lets the user to download them:</p> <p></p>"},{"location":"developers/settings/resource-handler/#exporting-example","title":"Exporting example","text":"<p>Here is an example of a component that supports exporting a CSV file resource based on the component's current configuration:</p> <pre><code>public class MyComponent implements SettingSpecifierProvider,\nSettingResourceHandler {\n\n/** The setting resource key for a CSV configuration file. */\npublic static final String RESOURCE_KEY_CSV_CONFIG = \"csvConfig\";\n\nprivate int max = 1;\nprivate boolean enabled = true;\n\n@Override\npublic Collection&lt;String&gt; supportedCurrentResourceSettingKeys() {\nreturn Collections.singletonList(RESOURCE_KEY_CSV_CONFIG);\n}\n\n@Override\npublic Iterable&lt;Resource&gt; currentSettingResources(String settingKey) {\nif ( !RESOURCE_KEY_CSV_CONFIG.equals(settingKey) ) {\nreturn null;\n}\n\nStringBuilder buf = new StringBuilder();\nbuf.append(\"max,enabled\\r\\n\");\nbuf.append(max).append(',').append(enabled).append(\"\\r\\n\");\n\nreturn Collections.singleton(new ByteArrayResource(\nbuf.toString().getBytes(UTF_8), \"My Component CSV Config\") {\n\n@Override\npublic String getFilename() {\nreturn \"my-component-config.csv\";\n}\n\n});\n}\n}\n</code></pre>"},{"location":"developers/settings/singleton/","title":"Singleton Service","text":""},{"location":"developers/settings/specifier/","title":"Settings Specifier","text":"<p>The <code>net.solarnetwork.settings.SettingSpecifier</code> API defines metadata for a single configurable property in the Settings API. The API looks like this:</p> <pre><code>public interface SettingSpecifier {\n\n/**\n     * A unique identifier for the type of setting specifier this represents.\n     *\n     * &lt;p&gt;\n     * Generally this will be a fully-qualified interface name.\n     * &lt;/p&gt;\n     *\n     * @return the type\n     */\nString getType();\n\n/**\n     * Localizable text to display with the setting's content.\n     *\n     * @return the title\n     */\nString getTitle();\n\n}\n</code></pre> <p>This interface is very simple, and extended by more specialized interfaces that form more useful setting types.</p> <p>Note</p> <p>A <code>SettingSpecifier</code> instance is often referred to simply as a setting.</p> <p>Here is a view of the class hierarchy that builds off of this interface:</p> <p></p> <p>Note</p> <p>The <code>SettingSpecifier</code> API defines metadata about a configurable property, but not methods to view or change that property's value. The Settings Service provides methods for managing setting values.</p>"},{"location":"developers/settings/specifier/#settings-playpen","title":"Settings Playpen","text":"<p>The Settings Playpen plugin demonstrates most of the available setting types, and is a great way to see how the settings can be used.</p>"},{"location":"developers/settings/specifier/#text-field","title":"Text Field","text":"<p>The <code>TextFieldSettingSpecifier</code> defines a simple string-based configurable property and is the most common setting type. The setting defines a <code>key</code> that maps to a setter method on its associated component class. In the SolarNode GUI a text field is rendered as an HTML form text input, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicTextFieldSettingSpecifier</code> class provides the standard implementation of this API. A standard text field setting is created like this:</p> <pre><code>new BasicTextFieldSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\");\n\n// or without any default value\nnew BasicTextFieldSettingSpecifier(\"myProperty\", null);\n</code></pre> <p>Tip</p> <p>Setting values are generally treated as strings within the Settings API, however other basic data types such as integers and numbers can be used as well. You can also publish a \"proxy\" setting that manages a complex data type as a string, and en/decode the complex type in your component accessor methods.</p> <p>For example a <code>Map&lt;String, String&gt;</code> setting could be published as a text field setting that en/decodes the <code>Map</code> into a delimited string value, for example <code>name=Test, color=red</code>.</p>"},{"location":"developers/settings/specifier/#secure-text-field","title":"Secure Text Field","text":"<p>The <code>BasicTextFieldSettingSpecifier</code> can also be used for \"secure\" text fields where the field's content is obscured from view. In the SolarNode GUI a secure text field is rendered as an HTML password form input like this:</p> <p></p> <p>A standard secure text field setting is created by passing a third <code>true</code> argument, like this:</p> <pre><code>new BasicTextFieldSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\", true);\n\n// or without any default value\nnew BasicTextFieldSettingSpecifier(\"myProperty\", null, true);\n</code></pre>"},{"location":"developers/settings/specifier/#text-area","title":"Text Area","text":"<p>The <code>TextAreaSettingSpecifier</code> defines a simple string-based configurable property for a larger text value, loaded as an external file using the SettingResourceHandler API. In the SolarNode GUI a text area is rendered as an HTML form text area with an associated button to upload the content, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicTextAreaSettingSpecifier</code> class provides the standard implementation of this API. A standard text field setting is created like this:</p> <pre><code>new BasicTextAreaSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\");\n\n// or without any default value\nnew BasicTextAreaSettingSpecifier(\"myProperty\", null);\n</code></pre>"},{"location":"developers/settings/specifier/#direct-text-area","title":"Direct Text Area","text":"<p>The <code>BasicTextAreaSettingSpecifier</code> can also be used for \"direct\" text areas where the field's content is not uploaded as an external file. In the SolarNode GUI a direct text area is rendered as an HTML form text area, like this:</p> <p></p> <p>A standard direct text area setting is created by passing a third <code>true</code> argument, like this:</p> <pre><code>new BasicTextAreaSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\", true);\n\n// or without any default value\nnew BasicTextAreaSettingSpecifier(\"myProperty\", null, true);\n</code></pre>"},{"location":"developers/settings/specifier/#toggle","title":"Toggle","text":"<p>The <code>ToggleSettingSpecifier</code> defines a boolean configurable property. In the SolarNode GUI a toggle is rendered as an HTML form button, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicToggleSettingSpecifier</code> class provides the standard implementation of this API. A standard toggle setting is created like this:</p> <pre><code>new BasicToggleSettingSpecifier(\"toggle\", false); // default \"off\"\n\nnew BasicToggleSettingSpecifier(\"toggle\", true);  // default \"on\"\n</code></pre>"},{"location":"developers/settings/specifier/#file","title":"File","text":"<p>TODO</p>"},{"location":"users/","title":"User Guide","text":"<p>TODO</p>"},{"location":"users/configuration/","title":"Configuration","text":"<p>SolarNode components can support configurable properties grouped into namespaces. Each namespace is configured in a properties file located at  <code>${CONF_DIR}/services/${namespace}.properties</code>.</p> <p>Configuration location</p> <p>The <code>${CONF_DIR}</code> location is <code>/etc/solarnode</code> in SolarNodeOS.</p>"},{"location":"users/configuration/#example","title":"Example","text":"<p>Imagine a component uses the configuration namespace <code>com.example.service</code> and supports a configurable property named <code>max-threads</code> that accepts an integer value you would like to configure as <code>4</code>. You would create a <code>com.example.service.properties</code> file like:</p> ${CONF_DIR}/services/com.example.service.properties<pre><code>max-threads = 4\n</code></pre>"},{"location":"users/logging/","title":"Logging","text":"<p>TODO</p>"},{"location":"users/placeholders/","title":"Placeholders","text":"<p>SolarNode supports placeholders in some setting values, such as datum data source IDs. These allow you to define a set of parameters that can be consistently applied to many settings.</p> <p>For example, imagine you manage many SolarNode devices across different buildings or sites, You'd like to follow a naming convention for your datum data source ID values that include a code for the building the node is deployed in, along the lines of <code>/BUILDING/DEVICE</code>. You could define a placeholder <code>building</code> and then configure the source IDs like <code>/{building}/device</code>. On each node you'd define the <code>building</code> placeholder with a building-specific value, so at runtime the nodes would resolve actual source ID values with those names replacing the <code>{building}</code> placeholder.</p>"},{"location":"users/placeholders/#placeholder-syntax","title":"Placeholder syntax","text":"<p>Placeholders are written using the form <code>{name:default}</code> where <code>name</code> is the placeholder name and <code>default</code> is an optional default value to apply if no placeholder value exists for the given name. If a default value is not needed, omit the <code>colon</code> so the placeholder becomes just <code>{name}</code>.</p> <p>For example, imagine a set of placeholder values like</p> Name Value building OFFICE1 room BREAK <p>Here are some example settings with placeholders with what they would resolve to:</p> Input Resolved value <code>/{building}/meter</code> <code>/OFFICE1/meter</code> <code>/{building}/{room}/temp</code> <code>/OFFICE1/BREAK/temp</code> <code>/{building}/{floor:1}/{room}</code> <code>/OFFICE1/1/BREAK</code>"}]}